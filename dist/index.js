(()=>{"use strict";var __webpack_modules__={208(e,t,n){n.d(t,{A:()=>a});var o=n(601),s=n.n(o),r=n(314),i=n.n(r)()(s());i.push([e.id,".code-runner-button {\n    cursor: pointer;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    height: 22px;\n    width: 22px;\n    margin: 4px;\n    opacity: 0.4;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.code-runner-button:hover,\n.code-output-clear:hover {\n    opacity: 0.8;\n}\n\n.code-output {\n    position: relative;\n    width: 100%;\n    overflow-y: auto;\n    max-height: 25vh;\n    max-height: 25svh;\n    min-height: 3em;\n}\n\n.code-output > div {\n    font-size: calc(var(--mainFontSize) * 0.9);\n}\n\n.code-output-hourglass {\n    position: absolute;\n    bottom: 50%;\n    left: 50%;\n    transform: translate(-50%, 50%);\n    opacity: 0.5;\n}\n\n.code-output-clear {\n    position: absolute;\n    top: 0;\n    right: 0;\n    margin: 4px;\n    opacity: 0.4;\n    cursor: pointer;\n}\n",""]);const a=i},314(e){e.exports=function(e){var t=[];return t.toString=function(){return this.map(function(t){var n="",o=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),o&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),o&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n}).join("")},t.i=function(e,n,o,s,r){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(o)for(var a=0;a<this.length;a++){var c=this[a][0];null!=c&&(i[c]=!0)}for(var p=0;p<e.length;p++){var l=[].concat(e[p]);o&&i[l[0]]||(void 0!==r&&(void 0===l[5]||(l[1]="@layer".concat(l[5].length>0?" ".concat(l[5]):""," {").concat(l[1],"}")),l[5]=r),n&&(l[2]?(l[1]="@media ".concat(l[2]," {").concat(l[1],"}"),l[2]=n):l[2]=n),s&&(l[4]?(l[1]="@supports (".concat(l[4],") {").concat(l[1],"}"),l[4]=s):l[4]="".concat(s)),t.push(l))}},t}},601(e){e.exports=function(e){return e[1]}},72(e){var t=[];function n(e){for(var n=-1,o=0;o<t.length;o++)if(t[o].identifier===e){n=o;break}return n}function o(e,o){for(var r={},i=[],a=0;a<e.length;a++){var c=e[a],p=o.base?c[0]+o.base:c[0],l=r[p]||0,d="".concat(p," ").concat(l);r[p]=l+1;var u=n(d),f={css:c[1],media:c[2],sourceMap:c[3],supports:c[4],layer:c[5]};if(-1!==u)t[u].references++,t[u].updater(f);else{var h=s(f,o);o.byIndex=a,t.splice(a,0,{identifier:d,updater:h,references:1})}i.push(d)}return i}function s(e,t){var n=t.domAPI(t);n.update(e);return function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,s){var r=o(e=e||[],s=s||{});return function(e){e=e||[];for(var i=0;i<r.length;i++){var a=n(r[i]);t[a].references--}for(var c=o(e,s),p=0;p<r.length;p++){var l=n(r[p]);0===t[l].references&&(t[l].updater(),t.splice(l,1))}r=c}}},659(e){var t={};e.exports=function(e,n){var o=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");o.appendChild(n)}},540(e){e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},56(e,t,n){e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},825(e){e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var o="";n.supports&&(o+="@supports (".concat(n.supports,") {")),n.media&&(o+="@media ".concat(n.media," {"));var s=void 0!==n.layer;s&&(o+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),o+=n.css,s&&(o+="}"),n.media&&(o+="}"),n.supports&&(o+="}");var r=n.sourceMap;r&&"undefined"!=typeof btoa&&(o+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(r))))," */")),t.styleTagTransform(o,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},113(e){e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.nc=void 0;var __webpack_exports__={},injectStylesIntoStyleTag=__webpack_require__(72),injectStylesIntoStyleTag_default=__webpack_require__.n(injectStylesIntoStyleTag),styleDomAPI=__webpack_require__(825),styleDomAPI_default=__webpack_require__.n(styleDomAPI),insertBySelector=__webpack_require__(659),insertBySelector_default=__webpack_require__.n(insertBySelector),setAttributesWithoutAttributes=__webpack_require__(56),setAttributesWithoutAttributes_default=__webpack_require__.n(setAttributesWithoutAttributes),insertStyleElement=__webpack_require__(540),insertStyleElement_default=__webpack_require__.n(insertStyleElement),styleTagTransform=__webpack_require__(113),styleTagTransform_default=__webpack_require__.n(styleTagTransform),style=__webpack_require__(208),options={};options.styleTagTransform=styleTagTransform_default(),options.setAttributes=setAttributesWithoutAttributes_default(),options.insert=insertBySelector_default().bind(null,"head"),options.domAPI=styleDomAPI_default(),options.insertStyleElement=insertStyleElement_default();var update=injectStylesIntoStyleTag_default()(style.A,options);const src_style=style.A&&style.A.locals?style.A.locals:void 0,AsyncFunction=Object.getPrototypeOf(async function(){}).constructor,GeneratorFunction=Object.getPrototypeOf(function*(){}).constructor,AsyncGeneratorFunction=Object.getPrototypeOf(async function*(){}).constructor,SandboxGlobal=function(e){for(const t in e)this[t]=e[t]};class ExecContext{constructor(e,t,n,o,s,r,i,a,c,p,l,d){this.ctx=e,this.constants=t,this.tree=n,this.getSubscriptions=o,this.setSubscriptions=s,this.changeSubscriptions=r,this.setSubscriptionsGlobal=i,this.changeSubscriptionsGlobal=a,this.evals=c,this.registerSandboxFunction=p,this.allowJit=l,this.evalContext=d}}function createContext(e,t){const n=new SandboxGlobal(t.globals),o={sandbox:e,globalsWhitelist:new Set(Object.values(t.globals)),prototypeWhitelist:new Map([...t.prototypeWhitelist].map(e=>[e[0].prototype,e[1]])),options:t,globalScope:new Scope(null,t.globals,n),sandboxGlobal:n,ticks:{ticks:0n,tickLimit:t.executionQuota},sandboxedFunctions:new WeakSet};return o.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set),o}function createExecContext(sandbox,executionTree,evalContext){const evals=new Map,execContext=new ExecContext(sandbox.context,executionTree.constants,executionTree.tree,new Set,new WeakMap,new WeakMap,sandbox.setSubscriptions,sandbox.changeSubscriptions,evals,e=>sandbox.sandboxFunctions.set(e,execContext),!!evalContext,evalContext);if(evalContext){const func=evalContext.sandboxFunction(execContext),asyncFunc=evalContext.sandboxAsyncFunction(execContext);evals.set(Function,func),evals.set(AsyncFunction,asyncFunc),evals.set(GeneratorFunction,func),evals.set(AsyncGeneratorFunction,asyncFunc),evals.set(eval,evalContext.sandboxedEval(func)),evals.set(setTimeout,evalContext.sandboxedSetTimeout(func,execContext)),evals.set(setInterval,evalContext.sandboxedSetInterval(func,execContext)),evals.set(clearTimeout,evalContext.sandboxedClearTimeout(execContext)),evals.set(clearInterval,evalContext.sandboxedClearInterval(execContext));for(const[e,t]of evals)sandbox.context.prototypeWhitelist.set(t.prototype,new Set),sandbox.context.prototypeWhitelist.set(e.prototype,new Set)}return execContext}class CodeString{constructor(e){this.ref={str:""},e instanceof CodeString?(this.ref=e.ref,this.start=e.start,this.end=e.end):(this.ref.str=e,this.start=0,this.end=e.length)}substring(e,t){if(!this.length)return this;(e=this.start+e)<0&&(e=0),e>this.end&&(e=this.end),(t=void 0===t?this.end:this.start+t)<0&&(t=0),t>this.end&&(t=this.end);const n=new CodeString(this);return n.start=e,n.end=t,n}get length(){const e=this.end-this.start;return e<0?0:e}char(e){if(this.start!==this.end)return this.ref.str[this.start+e]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const e=/^\s+/.exec(this.toString()),t=new CodeString(this);return e&&(t.start+=e[0].length),t}slice(e,t){return e<0&&(e=this.end-this.start+e),e<0&&(e=0),void 0===t&&(t=this.end-this.start),t<0&&(t=this.end-this.start+t),t<0&&(t=0),this.substring(e,t)}trim(){const e=this.trimStart(),t=/\s+$/.exec(e.toString());return t&&(e.end-=t[0].length),e}valueOf(){return this.toString()}}function keysOnly(e){const t=Object.assign({},e);for(const e in t)t[e]=!0;return t}const reservedWords=new Set(["await","break","case","catch","class","const","continue","debugger","default","delete","do","else","enum","export","extends","false","finally","for","function","if","implements","import","in","instanceof","let","new","null","return","super","switch","this","throw","true","try","typeof","var","void","while","with"]);class Scope{constructor(e,t={},n){this.const={},this.let={},this.var={};const o=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=o?this.let:keysOnly(t),this.var=o?keysOnly(t):this.var,this.globals=null===e?keysOnly(t):{},this.functionThis=n}get(e){const t="this"===e,n=this.getWhereValScope(e,t);return n&&t?new Prop({this:n.functionThis},e,!1,!1,!0):n?new Prop(n.allVars,e,e in n.const,e in n.globals,!0):new Prop(void 0,e)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");const n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(null===n.context)throw new TypeError(`Cannot set properties of null, (setting '${e}')`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n.prop]=t,n}getWhereValScope(e,t){return t?void 0!==this.functionThis?this:this.parent?.getWhereValScope(e,t)||null:!(e in this.allVars)||e in{}&&!Sandbox_min_hasOwnProperty(this.allVars,e)?this.parent?.getWhereValScope(e,t)||null:this}getWhereVarScope(e,t=!1){return!(e in this.allVars)||e in{}&&!Sandbox_min_hasOwnProperty(this.allVars,e)?null===this.parent||t||void 0!==this.functionThis?this:this.parent.getWhereVarScope(e,t):this}declare(e,t,n=void 0,o=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");const s=this.getWhereVarScope(e,"var"!==t);if("var"===t){if(s.var[e])return s.allVars[e]=n,o?s.globals[e]=!0:delete s.globals[e],new Prop(s.allVars,e,!1,s.globals[e],!0);if(e in s.allVars)throw new SyntaxError(`Identifier '${e}' has already been declared`)}if(e in s.allVars)throw new SyntaxError(`Identifier '${e}' has already been declared`);return o&&(s.globals[e]=!0),s[t][e]=!0,s.allVars[e]=n,new Prop(this.allVars,e,"const"===t,o,!0)}}class LocalScope{}class SandboxError extends Error{}class SandboxExecutionQuotaExceededError extends SandboxError{}class SandboxExecutionTreeError extends SandboxError{}class SandboxCapabilityError extends SandboxError{}class SandboxAccessError extends SandboxError{}function isLisp(e){return Array.isArray(e)&&"number"==typeof e[0]&&0!==e[0]&&88!==e[0]}class Prop{constructor(e,t,n=!1,o=!1,s=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=o,this.isVariable=s}get(e){const t=this.context;if(void 0===t)throw new ReferenceError(`${this.prop.toString()} is not defined`);if(null===t)throw new TypeError(`Cannot read properties of null, (reading '${this.prop.toString()}')`);return e.getSubscriptions.forEach(e=>e(t,this.prop.toString())),t[this.prop]}}function Sandbox_min_hasOwnProperty(e,t){return Object.prototype.hasOwnProperty.call(e,t)}class ExecReturn{constructor(e,t,n,o=!1,s=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=o,this.continueLoop=s}}const optional={};function generateArgs(e,t){const n={};return e.forEach((e,o)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(o):n[e]=t[o]}),n}function createFunction(e,t,n,o,s,r){if(o.ctx.options.forbidFunctionCreation)throw new SandboxCapabilityError("Function creation is forbidden");let i;return i=void 0===r?(...r)=>{const i=generateArgs(e,r);return executeTree(n,o,t,void 0===s?[]:[new Scope(s,i)]).result}:function(...r){const i=generateArgs(e,r);return executeTree(n,o,t,void 0===s?[]:[new Scope(s,i,this)]).result},o.registerSandboxFunction(i),o.ctx.sandboxedFunctions.add(i),i}function createFunctionAsync(e,t,n,o,s,r){if(o.ctx.options.forbidFunctionCreation)throw new SandboxCapabilityError("Function creation is forbidden");if(!o.ctx.prototypeWhitelist?.has(Promise.prototype))throw new SandboxCapabilityError("Async/await not permitted");let i;return i=void 0===r?async(...r)=>{const i=generateArgs(e,r);return(await executeTreeAsync(n,o,t,void 0===s?[]:[new Scope(s,i)])).result}:async function(...r){const i=generateArgs(e,r);return(await executeTreeAsync(n,o,t,void 0===s?[]:[new Scope(s,i,this)])).result},o.registerSandboxFunction(i),o.ctx.sandboxedFunctions.add(i),i}function assignCheck(e,t,n="assign"){if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if(e.isConst)throw new TypeError("Assignment to constant variable.");if(e.isGlobal)throw new SandboxAccessError(`Cannot ${n} property '${e.prop.toString()}' of a global object`);if(null===e.context)throw new TypeError("Cannot set properties of null");if("function"==typeof e.context[e.prop]&&!Sandbox_min_hasOwnProperty(e.context,e.prop))throw new SandboxAccessError(`Override prototype property '${e.prop.toString()}' not allowed`);"delete"===n?Sandbox_min_hasOwnProperty(e.context,e.prop)&&(t.changeSubscriptions.get(e.context)?.forEach(t=>t({type:"delete",prop:e.prop.toString()})),t.changeSubscriptionsGlobal.get(e.context)?.forEach(t=>t({type:"delete",prop:e.prop.toString()}))):Sandbox_min_hasOwnProperty(e.context,e.prop)?(t.setSubscriptions.get(e.context)?.get(e.prop.toString())?.forEach(e=>e({type:"replace"})),t.setSubscriptionsGlobal.get(e.context)?.get(e.prop.toString())?.forEach(e=>e({type:"replace"}))):(t.changeSubscriptions.get(e.context)?.forEach(t=>t({type:"create",prop:e.prop.toString()})),t.changeSubscriptionsGlobal.get(e.context)?.forEach(t=>t({type:"create",prop:e.prop.toString()})))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}class If{constructor(e,t){this.t=e,this.f=t}}const literalRegex=/(\$\$)*(\$)?\${(\d+)}/g,ops=new Map;function addOps(e,t){ops.set(e,t)}function isPropertyKey(e){return["string","number","symbol"].includes(typeof e)}function hasPossibleProperties(e){return null!=e}function getGlobalProp(e,t,n){if(!e)return;const o="function"==typeof e;e instanceof Prop&&(n||(n=e),e=e.get(t));const s=n?.prop||"prop";if(e===globalThis)return new Prop({[s]:t.ctx.sandboxGlobal},s,n?.isConst||!1,!1,n?.isVariable||!1);const r=o&&t.evals.get(e);return r?new Prop({[s]:r},s,n?.isConst||!1,!0,n?.isVariable||!1):void 0}function valueOrProp(e,t){return e instanceof Prop?e.get(t):e!==optional?e:void 0}function execMany(e,t,n,o,s,r,i){t===execSync?_execManySync(e,n,o,s,r,i):_execManyAsync(e,n,o,s,r,i).catch(o)}function _execManySync(e,t,n,o,s,r){const i=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone(n=>execSync(e,t[a],o,s,n,r)).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(s.ctx.auditReport,c,!0));i.push(c)}n(void 0,i)}async function _execManyAsync(e,t,n,o,s,r){const i=[];for(let a=0;a<t.length;a++){let c;try{let n;c=!0===(n=asyncDone(n=>execAsync(e,t[a],o,s,n,r))).isInstant?n.instant:(await n.p).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(s.ctx.auditReport,c,!0));i.push(c)}n(void 0,i)}function asyncDone(e){let t,n=!1;const o=new Promise((o,s)=>{e((e,r)=>{e?s(e):(n=!0,t=r,o({result:r}))})});return{isInstant:n,instant:t,p:o}}function syncDone(e){let t,n;if(e((e,o)=>{n=e,t=o}),n)throw n;return{result:t}}async function execAsync(e,t,n,o,s,r){let i=s;const a=new Promise(e=>{i=(t,n)=>{s(t,n),e()}});if(!_execNoneRecurse(e,t,n,o,i,!0,r)&&isLisp(t)){let s,a=t[0];try{let i;s=!0===(i=asyncDone(s=>execAsync(e,t[1],n,o,s,r))).isInstant?i.instant:(await i.p).result}catch(e){return void i(e)}let c,p=s;try{p=s instanceof Prop?s.get(o):s}catch(e){return void i(e)}if(20===a||21===a){if(null==p)return void i(void 0,optional);a=20===a?1:5}if(p===optional){if(1===a||5===a)return void i(void 0,p);p=void 0}if(89===a&&null!=p)return void i(void 0,p);try{let s;c=!0===(s=asyncDone(s=>execAsync(e,t[2],n,o,s,r))).isInstant?s.instant:(await s.p).result}catch(e){return void i(e)}let l=c;try{l=c instanceof Prop?c.get(o):c}catch(e){return void i(e)}l===optional&&(l=void 0),performOp({op:a,exec:execAsync,done:i,ticks:e,a:p,b:l,obj:s,context:o,scope:n,bobj:c,inLoopOrSwitch:r,tree:t})}await a}function execSync(e,t,n,o,s,r){if(!_execNoneRecurse(e,t,n,o,s,!1,r)&&isLisp(t)){let i,a=t[0];try{i=syncDone(s=>execSync(e,t[1],n,o,s,r)).result}catch(e){return void s(e)}let c,p=i;try{p=i instanceof Prop?i.get(o):i}catch(e){return void s(e)}if(20===a||21===a){if(null==p)return void s(void 0,optional);a=20===a?1:5}if(p===optional){if(1===a||5===a)return void s(void 0,p);p=void 0}if(89===a&&null!=p)return void s(void 0,p);try{c=syncDone(s=>execSync(e,t[2],n,o,s,r)).result}catch(e){return void s(e)}let l=c;try{l=c instanceof Prop?c.get(o):c}catch(e){return void s(e)}l===optional&&(l=void 0),performOp({op:a,exec:execSync,done:s,ticks:e,a:p,b:l,obj:i,context:o,scope:n,bobj:c,inLoopOrSwitch:r,tree:t})}}function checkHaltAsync(e,t){let n,o,s=!1,r=e.ctx.sandbox.halted,i=()=>{};const a=new Promise(t=>{i=()=>{o.unsubscribe(),n.unsubscribe(),t()},o=e.ctx.sandbox.subscribeHalt(()=>{r=!0}),n=e.ctx.sandbox.subscribeResume(()=>{r=!1,s&&i()})});return t.finally(()=>{s=!0,r||i()}).catch(()=>{}),Promise.allSettled([t,a]).then(()=>t)}function checkHaltExpectedTicks(e,t=0){const n=e.context.ctx.sandbox,o=e.context.ctx.options,{ticks:s,scope:r,context:i,done:a,op:c}=e;if(n.halted){const t=n.subscribeResume(()=>{t.unsubscribe();try{const t=ops.get(c);if(!t)return void a(new SyntaxError("Unknown operator: "+c));t(e)}catch(e){if(o.haltOnSandboxError&&e instanceof SandboxError){const t=n.subscribeResume(()=>{t.unsubscribe(),a(e)});n.haltExecution({error:e,ticks:s,scope:r,context:i})}else a(e)}});return!0}if(s.tickLimit&&s.tickLimit<=s.ticks+BigInt(t)){const t=n.subscribeResume(()=>{t.unsubscribe();try{const t=ops.get(c);if(!t)return void a(new SyntaxError("Unknown operator: "+c));t(e)}catch(e){if(i.ctx.options.haltOnSandboxError&&e instanceof SandboxError){const t=n.subscribeResume(()=>{t.unsubscribe(),a(e)});n.haltExecution({error:e,ticks:s,scope:r,context:i})}else a(e)}}),o=new SandboxExecutionQuotaExceededError("Execution quota exceeded");return n.haltExecution({error:o,ticks:s,scope:r,context:i}),!0}return!1}function performOp(e){const{done:t,op:n,ticks:o,context:s,scope:r}=e;o.ticks++;const i=s.ctx.sandbox;if(!checkHaltExpectedTicks(e))try{const o=ops.get(n);if(!o)return void t(new SandboxExecutionTreeError("Unknown operator: "+n));o(e)}catch(e){if(s.ctx.options.haltOnSandboxError&&e instanceof SandboxError){const n=i.subscribeResume(()=>{n.unsubscribe(),t(e)});i.haltExecution({error:e,ticks:o,scope:r,context:s})}else t(e)}}addOps(1,({done:e,a:t,b:n,obj:o,context:s,scope:r})=>{if(null===t)throw new TypeError(`Cannot read properties of null (reading '${n?.toString()}')`);if(!isPropertyKey(n))try{n=`${n}`}catch(t){return void e(t)}if(void 0===t&&void 0===o&&"string"==typeof n){const t=r.get(n);return t.context===s.ctx.sandboxGlobal&&s.ctx.options.audit&&s.ctx.auditReport?.globalsAccess.add(n),void e(void 0,getGlobalProp(t.context?t.context[t.prop]:void 0,s,t)||t)}if(void 0===t)throw new TypeError(`Cannot read properties of undefined (reading '${n.toString()}')`);if(!hasPossibleProperties(t))return void e(void 0,new Prop(void 0,n));const i="function"==typeof t||!Sandbox_min_hasOwnProperty(t,n);if(s.ctx.options.audit&&i){let e=Object.getPrototypeOf(t);do{Sandbox_min_hasOwnProperty(e,n)&&(s.ctx.auditReport&&!s.ctx.auditReport.prototypeAccess[e.constructor.name]&&(s.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),s.ctx.auditReport?.prototypeAccess[e.constructor.name].add(n))}while(e=Object.getPrototypeOf(e))}if(i){if("function"==typeof t&&Sandbox_min_hasOwnProperty(t,n)){const o=s.ctx.prototypeWhitelist.get(t.prototype),r=s.ctx.options.prototypeReplacements.get(t);if(r)return void e(void 0,new Prop(r(t,!0),n));if((!o||o.size&&!o.has(n))&&!s.ctx.sandboxedFunctions.has(t))throw new SandboxAccessError(`Static method or property access not permitted: ${t.name}.${n.toString()}`)}let o=t;for(;o=Object.getPrototypeOf(o);)if(Sandbox_min_hasOwnProperty(o,n)||"__proto__"===n){const r=s.ctx.prototypeWhitelist.get(o),i=s.ctx.options.prototypeReplacements.get(o.constructor);if(i)return void e(void 0,new Prop(i(t,!1),n));if(r&&(!r.size||r.has(n))||s.ctx.sandboxedFunctions.has(o.constructor))break;if("__proto__"===n)throw new SandboxAccessError("Access to prototype of global object is not permitted");throw new SandboxAccessError(`Method or property access not permitted: ${o.constructor.name}.${n.toString()}`)}}const a=t[n];if("function"==typeof t&&"prototype"===n&&!s.ctx.sandboxedFunctions.has(t))throw new SandboxAccessError("Access to prototype of global object is not permitted");if("__proto__"===n&&!s.ctx.sandboxedFunctions.has(a?.constructor))throw new SandboxAccessError("Access to prototype of global object is not permitted");const c=getGlobalProp(a,s);if(c)return void e(void 0,c);const p=o instanceof Prop&&o.isGlobal||"function"==typeof t&&!s.ctx.sandboxedFunctions.has(t)||s.ctx.globalsWhitelist.has(t);e(void 0,new Prop(t,n,!1,p,!1))}),addOps(5,({done:e,a:t,b:n,obj:o,context:s})=>{if(s.ctx.options.forbidFunctionCalls)throw new SandboxCapabilityError("Function invocations are not allowed");if("function"!=typeof t)throw new TypeError(`${"symbol"==typeof o.prop?"Symbol":o.prop} is not a function`);const r=n.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>valueOrProp(e,s));if("function"==typeof o){let t=o(...r);return t=t instanceof Promise?checkHaltAsync(s,t):getGlobalProp(t,s)||t,void e(void 0,t)}if(o.context[o.prop]===JSON.stringify&&s.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(const e of Object.keys(n))s.getSubscriptions.forEach(t=>t(n,e)),t(n[e])}};t(r[0])}if(o.context instanceof Array&&arrayChange.has(o.context[o.prop])&&(s.changeSubscriptions.get(o.context)||s.changeSubscriptionsGlobal.get(o.context))){let e,t=!1;if("push"===o.prop)e={type:"push",added:r},t=!!r.length;else if("pop"===o.prop)e={type:"pop",removed:o.context.slice(-1)},t=!!e.removed.length;else if("shift"===o.prop)e={type:"shift",removed:o.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===o.prop)e={type:"unshift",added:r},t=!!r.length;else if("splice"===o.prop)e={type:"splice",startIndex:r[0],deleteCount:void 0===r[1]?o.context.length:r[1],added:r.slice(2),removed:o.context.slice(r[0],void 0===r[1]?void 0:r[0]+r[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===o.prop||"sort"===o.prop)e={type:o.prop},t=!!o.context.length;else if("copyWithin"===o.prop){const n=void 0===r[2]?o.context.length-r[1]:Math.min(o.context.length,r[2]-r[1]);e={type:"copyWithin",startIndex:r[0],endIndex:r[0]+n,added:o.context.slice(r[1],r[1]+n),removed:o.context.slice(r[0],r[0]+n)},t=!!e.added.length||!!e.removed.length}t&&(s.changeSubscriptions.get(o.context)?.forEach(t=>t(e)),s.changeSubscriptionsGlobal.get(o.context)?.forEach(t=>t(e)))}o.get(s);let i=o.context[o.prop](...r);i=i instanceof Promise?checkHaltAsync(s,i):getGlobalProp(i,s)||i,e(void 0,i)}),addOps(22,({done:e,b:t})=>{let n={};for(const e of t)e.key instanceof SpreadObject?n={...n,...e.key.item}:n[e.key]=e.val;e(void 0,n)}),addOps(6,({done:e,a:t,b:n})=>e(void 0,new KeyVal(t,n))),addOps(12,({done:e,b:t,context:n})=>{e(void 0,t.map(e=>e instanceof SpreadArray?[...e.item]:[e]).flat().map(e=>valueOrProp(e,n)))}),addOps(23,({done:e,b:t})=>e(void 0,t)),addOps(35,({done:e,b:t})=>{switch(t){case"true":return e(void 0,!0);case"false":return e(void 0,!1);case"null":return e(void 0,null);case"undefined":return e(void 0,void 0);case"NaN":return e(void 0,NaN);case"Infinity":return e(void 0,1/0)}e(new Error("Unknown symbol: "+t))}),addOps(7,({done:e,b:t})=>e(void 0,Number(t.replace(/_/g,"")))),addOps(83,({done:e,b:t})=>e(void 0,BigInt(t.replace(/_/g,"")))),addOps(2,({done:e,b:t,context:n})=>e(void 0,n.constants.strings[parseInt(t)])),addOps(85,({done:e,b:t,context:n})=>{const o=n.constants.regexes[parseInt(t)];if(!n.ctx.globalsWhitelist.has(RegExp))throw new SandboxCapabilityError("Regex not permitted");e(void 0,new RegExp(o.regex,o.flags))}),addOps(84,({exec:e,done:t,ticks:n,b:o,context:s,scope:r})=>{const i=s.constants.literals[parseInt(o)],[,a,c]=i,p=[];let l;const d=[];for(;l=literalRegex.exec(a);)l[2]||(p.push(c[parseInt(l[3],10)]),d.push(l[3]));e(n,p,r,s,(e,n)=>{const o={};if(e)t(e);else{for(const e of Object.keys(n)){const t=d[e];o[t]=n[e]}t(void 0,a.replace(/(\\\\)*(\\)?\${(\d+)}/g,(e,t,n,r)=>n?e:(t||"")+`${valueOrProp(o[r],s)}`))}})}),addOps(18,({done:e,b:t})=>{e(void 0,new SpreadArray(t))}),addOps(17,({done:e,b:t})=>{e(void 0,new SpreadObject(t))}),addOps(24,({done:e,b:t})=>e(void 0,!t)),addOps(64,({done:e,b:t})=>e(void 0,~t)),addOps(25,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,++t.context[t.prop])}),addOps(26,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,t.context[t.prop]++)}),addOps(27,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,--t.context[t.prop])}),addOps(28,({done:e,obj:t,context:n})=>{assignCheck(t,n),e(void 0,t.context[t.prop]--)}),addOps(9,({done:e,b:t,obj:n,context:o,scope:s,bobj:r})=>{if(assignCheck(n,o),n.isGlobal=r?.isGlobal||!1,n.isVariable){const o=s.getWhereValScope(n.prop,"this"===n.prop);if(null===o)throw new ReferenceError(`Cannot assign to undeclared variable '${n.prop.toString()}'`);return o.set(n.prop,t),n.isGlobal?o.globals[n.prop.toString()]=!0:delete o.globals[n.prop.toString()],void e(void 0,t)}e(void 0,n.context[n.prop]=t)}),addOps(66,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]+=t)}),addOps(65,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]-=t)}),addOps(67,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]/=t)}),addOps(69,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]*=t)}),addOps(68,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]**=t)}),addOps(70,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]%=t)}),addOps(71,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]^=t)}),addOps(72,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]&=t)}),addOps(73,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]|=t)}),addOps(76,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]<<=t)}),addOps(75,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]>>=t)}),addOps(74,({done:e,b:t,obj:n,context:o})=>{assignCheck(n,o),e(void 0,n.context[n.prop]>>>=t)}),addOps(57,({done:e,a:t,b:n})=>e(void 0,t>n)),addOps(56,({done:e,a:t,b:n})=>e(void 0,t<n)),addOps(55,({done:e,a:t,b:n})=>e(void 0,t>=n)),addOps(54,({done:e,a:t,b:n})=>e(void 0,t<=n)),addOps(52,({done:e,a:t,b:n})=>e(void 0,t==n)),addOps(32,({done:e,a:t,b:n})=>e(void 0,t===n)),addOps(53,({done:e,a:t,b:n})=>e(void 0,t!=n)),addOps(31,({done:e,a:t,b:n})=>e(void 0,t!==n)),addOps(29,({done:e,a:t,b:n})=>e(void 0,t&&n)),addOps(30,({done:e,a:t,b:n})=>e(void 0,t||n)),addOps(89,({done:e,a:t,b:n})=>e(void 0,t??n)),addOps(77,({done:e,a:t,b:n})=>e(void 0,t&n)),addOps(78,({done:e,a:t,b:n})=>e(void 0,t|n)),addOps(33,({done:e,a:t,b:n})=>e(void 0,t+n)),addOps(47,({done:e,a:t,b:n})=>e(void 0,t-n)),addOps(59,({done:e,b:t})=>e(void 0,+t)),addOps(58,({done:e,b:t})=>e(void 0,-t)),addOps(48,({done:e,a:t,b:n})=>e(void 0,t/n)),addOps(49,({done:e,a:t,b:n})=>e(void 0,t**n)),addOps(79,({done:e,a:t,b:n})=>e(void 0,t^n)),addOps(50,({done:e,a:t,b:n})=>e(void 0,t*n)),addOps(51,({done:e,a:t,b:n})=>e(void 0,t%n)),addOps(80,({done:e,a:t,b:n})=>e(void 0,t<<n)),addOps(81,({done:e,a:t,b:n})=>e(void 0,t>>n)),addOps(82,({done:e,a:t,b:n})=>e(void 0,t>>>n)),addOps(60,({exec:e,done:t,ticks:n,b:o,context:s,scope:r})=>{e(n,o,r,s,(e,n)=>{t(void 0,typeof valueOrProp(n,s))})}),addOps(62,({done:e,a:t,b:n})=>e(void 0,t instanceof n)),addOps(63,({done:e,a:t,b:n})=>e(void 0,t in n)),addOps(61,({done:e,context:t,bobj:n})=>{n instanceof Prop?(assignCheck(n,t,"delete"),n.isVariable?e(void 0,!1):e(void 0,delete n.context?.[n.prop])):e(void 0,!0)}),addOps(8,({done:e,b:t})=>e(void 0,t)),addOps(34,({done:e,a:t,b:n,scope:o,bobj:s})=>{e(void 0,o.declare(t,"var",n,s?.isGlobal||!1))}),addOps(3,({done:e,a:t,b:n,scope:o,bobj:s})=>{e(void 0,o.declare(t,"let",n,s?.isGlobal||!1))}),addOps(4,({done:e,a:t,b:n,scope:o,bobj:s})=>{e(void 0,o.declare(t,"const",n,s?.isGlobal||!1))}),addOps(11,({done:e,ticks:t,a:n,b:o,obj:s,context:r,scope:i})=>{if(n=[...n],"string"==typeof s[2]||s[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");s[2]=o=r.evalContext.lispifyFunction(new CodeString(s[2]),r.constants)}n.shift()?e(void 0,createFunctionAsync(n,o,t,r,i)):e(void 0,createFunction(n,o,t,r,i))}),addOps(37,({done:e,ticks:t,a:n,b:o,obj:s,context:r,scope:i})=>{if("string"==typeof s[2]||s[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");s[2]=o=r.evalContext.lispifyFunction(new CodeString(s[2]),r.constants)}const a=n.shift(),c=n.shift();let p;p=88===a?createFunctionAsync(n,o,t,r,i,c):createFunction(n,o,t,r,i,c),c&&i.declare(c,"var",p),e(void 0,p)}),addOps(10,({done:e,ticks:t,a:n,b:o,obj:s,context:r,scope:i})=>{if("string"==typeof s[2]||s[2]instanceof CodeString){if(!r.allowJit||!r.evalContext)throw new SandboxCapabilityError("Unevaluated code detected, JIT not allowed");s[2]=o=r.evalContext.lispifyFunction(new CodeString(s[2]),r.constants)}const a=n.shift(),c=n.shift();let p;c&&(i=new Scope(i,{})),p=88===a?createFunctionAsync(n,o,t,r,i,c):createFunction(n,o,t,r,i,c),c&&i.declare(c,"let",p),e(void 0,p)}),addOps(38,({exec:e,done:t,ticks:n,a:o,b:s,context:r,scope:i})=>{const[a,c,p,l,d,u,f]=o;let h=!0;const x=new Scope(i,{}),b={$$obj:void 0},g=new Scope(x,b);if(e===execAsync)(async()=>{let o;for(o=asyncDone(t=>e(n,l,x,r,t)),b.$$obj=!0===(o=asyncDone(t=>e(n,p,x,r,t))).isInstant?o.instant:(await o.p).result,o=asyncDone(t=>e(n,c,g,r,t)),a&&(h=!0===(o=asyncDone(t=>e(n,u,g,r,t))).isInstant?o.instant:(await o.p).result);h;){const i={};o=asyncDone(t=>e(n,f,new Scope(g,i),r,t)),!0===o.isInstant?o.instant:(await o.p).result;const a=await executeTreeAsync(n,r,s,[new Scope(x,i)],"loop");if(a instanceof ExecReturn&&a.returned)return void t(void 0,a);if(a instanceof ExecReturn&&a.breakLoop)break;o=asyncDone(t=>e(n,d,g,r,t)),h=!0===(o=asyncDone(t=>e(n,u,g,r,t))).isInstant?o.instant:(await o.p).result}t()})().catch(t);else{for(syncDone(t=>e(n,l,x,r,t)),b.$$obj=syncDone(t=>e(n,p,x,r,t)).result,syncDone(t=>e(n,c,g,r,t)),a&&(h=syncDone(t=>e(n,u,g,r,t)).result);h;){const o={};syncDone(t=>e(n,f,new Scope(g,o),r,t));const i=executeTree(n,r,s,[new Scope(x,o)],"loop");if(i instanceof ExecReturn&&i.returned)return void t(void 0,i);if(i instanceof ExecReturn&&i.breakLoop)break;syncDone(t=>e(n,d,g,r,t)),h=syncDone(t=>e(n,u,g,r,t)).result}t()}}),addOps(86,({done:e,a:t,context:n,inLoopOrSwitch:o})=>{if("switch"===o&&"continue"===t||!o)throw new TypeError("Illegal "+t+" statement");e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1,"break"===t,"continue"===t))}),addOps(13,({exec:e,done:t,ticks:n,a:o,b:s,context:r,scope:i,inLoopOrSwitch:a})=>{e(n,valueOrProp(o,r)?s.t:s.f,i,r,t,a)}),addOps(15,({exec:e,done:t,ticks:n,a:o,b:s,context:r,scope:i})=>{e(n,valueOrProp(o,r)?s.t:s.f,i,r,t,void 0)}),addOps(16,({done:e,a:t,b:n})=>e(void 0,new If(t,n))),addOps(14,({done:e,a:t,b:n})=>e(void 0,new If(t,n))),addOps(40,({exec:e,done:t,ticks:n,a:o,b:s,context:r,scope:i})=>{e(n,o,i,r,(o,a)=>{if(o)t(o);else if(a=valueOrProp(a,r),e===execSync){let o,c=!1;for(const p of s)if(c||(c=!p[1]||a===valueOrProp(syncDone(t=>e(n,p[1],i,r,t)).result,r))){if(!p[2])continue;if(o=executeTree(n,r,p[2],[i],"switch"),o.breakLoop)break;if(o.returned)return void t(void 0,o);if(!p[1])break}t()}else(async()=>{let o,c=!1;for(const p of s){let s;if(c||(c=!p[1]||a===valueOrProp(!0===(s=asyncDone(t=>e(n,p[1],i,r,t))).isInstant?s.instant:(await s.p).result,r))){if(!p[2])continue;if(o=await executeTreeAsync(n,r,p[2],[i],"switch"),o.breakLoop)break;if(o.returned)return void t(void 0,o);if(!p[1])break}}t()})().catch(t)})}),addOps(39,({exec:e,done:t,ticks:n,a:o,b:s,context:r,scope:i,inLoopOrSwitch:a})=>{const[c,p,l]=s;executeTreeWithDone(e,(o,s)=>{executeTreeWithDone(e,c=>{c?t(c):o?executeTreeWithDone(e,t,n,r,p,[new Scope(i)],a):t(void 0,s)},n,r,l,[new Scope(i,{})])},n,r,o,[new Scope(i)],a)}),addOps(87,({done:e})=>{e()}),addOps(45,({done:e,a:t,b:n,context:o})=>{if(!o.ctx.globalsWhitelist.has(t)&&!o.ctx.sandboxedFunctions.has(t))throw new SandboxAccessError(`Object construction not allowed: ${t.constructor.name}`);e(void 0,new t(...n))}),addOps(46,({done:e,b:t})=>{e(t)}),addOps(43,({done:e,a:t})=>e(void 0,t.pop())),addOps(0,({done:e})=>e());const unexecTypes=new Set([11,37,10,38,39,40,14,16,60]),currentTicks={current:{ticks:BigInt(0)}};function _execNoneRecurse(e,t,n,o,s,r,i){const a=r?execAsync:execSync;if(currentTicks.current=e,t instanceof Prop)try{s(void 0,t.get(o))}catch(e){s(e)}else if(t===optional)s();else if(Array.isArray(t)&&!isLisp(t))0===t[0]?s():execMany(e,a,t,s,n,o,i);else if(isLisp(t))if(42===t[0])execMany(e,a,t[1],s,n,o,i);else if(44===t[0])r?o.ctx.prototypeWhitelist?.has(Promise.prototype)?execAsync(e,t[1],n,o,async(e,t)=>{if(e)s(e);else try{s(void 0,await valueOrProp(t,o))}catch(e){s(e)}},i).catch(s):s(new SandboxCapabilityError("Async/await is not permitted")):s(new SyntaxError("Illegal use of 'await', must be inside async function"));else{if(!unexecTypes.has(t[0]))return!1;performOp({op:t[0],exec:a,done:s,ticks:e,a:t[1],b:t[2],obj:t,tree:t,context:o,scope:n,bobj:void 0,inLoopOrSwitch:i})}else s(void 0,t);return!0}function executeTree(e,t,n,o=[],s){return syncDone(r=>executeTreeWithDone(execSync,r,e,t,n,o,s)).result}async function executeTreeAsync(e,t,n,o=[],s){let r;return!0===(r=asyncDone(r=>executeTreeWithDone(execAsync,r,e,t,n,o,s))).isInstant?r.instant:(await r.p).result}function executeTreeWithDone(e,t,n,o,s,r=[],i){if(!s)return void t();if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=o.ctx.globalScope;for(;a=r.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,a instanceof LocalScope?void 0:null));o.ctx.options.audit&&!o.ctx.auditReport&&(o.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,o,s,c,i):_executeWithDoneAsync(t,n,o,s,c,i).catch(t)}function _executeWithDoneSync(e,t,n,o,s,r){if(!(o instanceof Array))throw new SyntaxError("Bad execution tree");let i=0;for(i=0;i<o.length;i++){let a,c;const p=o[i];try{execSync(t,p,s,n,(e,t)=>{c=e,a=t},r)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(p)&&8===p[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,o,s,r){if(!(o instanceof Array))throw new SyntaxError("Bad execution tree");let i=0;for(i=0;i<o.length;i++){let a,c;const p=o[i];try{await execAsync(t,p,s,n,(e,t)=>{c=e,a=t},r)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(p)&&8===p[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}function parseHexToInt(e){return e.match(/[^a-f0-9]/i)?NaN:parseInt(e,16)}function validateAndParseHex(e,t,n){const o=parseHexToInt(e);if(Number.isNaN(o)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return o}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,function(e,t,n,o,s,r,i,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==o)return parseUnicodeCodePointCode(o);if(void 0!==s)return parseUnicodeCode(s,r);if(void 0!==i)return parseUnicodeCode(i);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")})}function createLisp(e){return[e.op,e.a,e.b]}const NullLisp=createLisp({op:0,a:0,b:0}),lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}let lastType;const inlineIfElse=/^:/,elseIf=/^else(?![\w$])/,ifElse=/^if(?![\w$])/,space=/^\s/,expectTypes={splitter:{types:{opHigh:/^(\/|\*\*|\*(?!\*)|%)(?!=)/,op:/^(\+(?!(\+))|-(?!(-)))(?!=)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!=)|===|==)/,bitwiseShift:/^(<<|>>(?!>)|>>>)(?!=)/,bitwiseAnd:/^(&(?!&))(?!=)/,bitwiseXor:/^(\^)(?!=)/,bitwiseOr:/^(\|(?!\|))(?!=)/,boolOpAnd:/^(&&)/,boolOpOr:/^(\|\||instanceof(?![\w$])|in(?![\w$]))/,nullishCoalescing:/^\?\?/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.(?!\d))/},next:["expEnd"]},assignment:{types:{assignModify:/^(-=|\+=|\/=|\*\*=|\*=|%=|\^=|&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|--)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[(]/,incrementerAfter:/^(\+\+|--)/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^-(?!-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w$])/,delete:/^delete(?![\w$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z$_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z$_][a-zA-Z\d$_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0b[01]+(_[01]+)*|0o[0-7]+(_[0-7]+)*|0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[+-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w$])/,boolean:/^(true|false)(?![\w$])/,null:/^null(?![\w$])/,und:/^undefined(?![\w$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z$_][a-zA-Z\d$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w$])/,Infinity:/^Infinity(?![\w$])/,void:/^void(?![\w$])\s*/,await:/^await(?![\w$])\s*/,new:/^new(?![\w$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z$_][a-zA-Z\d$_]*)\s*(=)?/,return:/^return(?![\w$])/,throw:/^throw(?![\w$])\s*/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z$_][a-zA-Z\d$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z$_][a-zA-Z\d$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*do(?![\w$])\s*(\{)?/,while:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w$])\s*([a-zA-Z$_][\w$]*)?/,if:/^((([a-zA-Z$_][\w$]*)\s*:)?\s*)if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z$_][\w$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n=null;for(let o=0;o<t.length&&(n=t[o].exec(e),!n);o++);return n}const emptyString=new CodeString(""),okFirstChars=/^[+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|else|while|do|function)(?![\w$])|[\w$]+)/,semiColon=/^;/,insertedSemicolons=new WeakMap,quoteCache=new WeakMap;function restOfExp(e,t,n,o,s,r,i={}){if(!t.length)return t;i.words=i.words||[];let a=!0;const c=(n=n||[]).includes(semiColon);c&&(n=n.filter(e=>e!==semiColon));const p=insertedSemicolons.get(t.ref)||[],l=quoteCache.get(t.ref)||new Map;if(quoteCache.set(t.ref,l),o&&l.has(t.start-1))return t.substring(0,l.get(t.start-1)-t.start);let d,u=!1,f=!1,h="",x=!1,b=!1;for(d=0;d<t.length&&!f;d++){let g=t.char(d);if('"'===o||"'"===o||"`"===o){if("`"!==o||"$"!==g||"{"!==t.char(d+1)||u){if(g===o&&!u)return t.substring(0,d)}else d+=restOfExp(e,t.substring(d+2),[],"{").length+2;u=!u&&"\\"===g}else if(closings[g]){if(!b&&p[d+t.start]){if(b=!0,c)break;d--,h=";";continue}if(x&&"{"===g&&(x=!1),g===s){f=!0;break}{const n=restOfExp(e,t.substring(d+1),[],g);if(l.set(n.start-1,n.end),d+=n.length+1,a=!1,r){let e;(e=testMultiple(t.substring(d).toString(),r))&&(i.regRes=e,f=!0)}}}else if(o){if(g===closings[o])return t.substring(0,d)}else{let e,o,s=t.substring(d).toString();if(r){let e;if(e=testMultiple(s,r)){i.regRes=e,d++,f=!0;break}}if(o=aNumber.exec(s))d+=o[0].length-1,s=t.substring(d).toString();else if(h!=g){let o=null;if(";"===g||p[d+t.start]&&!a&&!b){if(c)o=[";"];else if(p[d+t.start]){b=!0,d--,h=";";continue}g=s=";"}else b=!1;o||(o=testMultiple(s,n)),o&&(f=!0),!f&&(e=wordReg.exec(s))&&(x=!0,e[0].length>1&&(i.words.push(e[1]),i.lastAnyWord=e[1],e[2]&&(i.lastWord=e[2])),e[0].length>2&&(d+=e[0].length-2))}if(a&&(okFirstChars.test(s)?f=!1:a=!1),f)break}h=g}if(o)throw new SyntaxError("Unclosed '"+o+"'");return i&&(i.oneliner=x),t.substring(0,d)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach(e=>{lispTypes.set(e,t)})},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/},typesCreate={createArray:12,createObject:22,group:23,arrayProp:19,call:5,prop:1,"?prop":20,"?call":21};setLispType(["createArray","createObject","group","arrayProp","call"],(e,t,n,o,s,r)=>{let i=emptyString;const a=[];let c=!1,p=o[0].length;const l=p;for(;p<n.length&&!c;)i=restOfExp(e,n.substring(p),[closingsCreate[t],/^,/]),p+=i.length,i.trim().length&&a.push(i),","!==n.char(p)?c=!0:p++;const d=["value","modifier","prop","incrementerBefore","expEnd"];let u,f;switch(t){case"group":case"arrayProp":u=lispifyExpr(e,n.substring(l,p));break;case"call":case"createArray":u=a.map(t=>lispify(e,t,[...d,"spreadArray"]));break;case"createObject":u=a.map(t=>{let n;t=t.trimStart();let o="";if(f=expectTypes.expFunction.types.function.exec("function "+t),f)o=f[2].trimStart(),n=lispify(e,new CodeString("function "+t.toString().replace(o,"")));else{const s=restOfExp(e,t,[/^:/]);o=lispify(e,s,[...d,"spreadObject"]),1===o[0]&&(o=o[2]),n=lispify(e,t.substring(s.length+1))}return createLisp({op:6,a:o,b:n})})}const h="arrayProp"===t?o[1]?20:1:"call"===t?o[1]?21:5:typesCreate[t];r.lispTree=lispify(e,n.substring(p+1),expectTypes[s].next,createLisp({op:h,a:r.lispTree,b:u}))});const modifierTypes={inverse:64,not:24,positive:59,negative:58,typeof:60,delete:61};setLispType(["inverse","not","negative","positive","typeof","delete"],(e,t,n,o,s,r)=>{const i=restOfExp(e,n.substring(o[0].length),[/^([^\s.?\w$]|\?[^.])/]);r.lispTree=lispify(e,n.substring(i.length+o[0].length),restOfExp.next,createLisp({op:modifierTypes[t],a:r.lispTree,b:lispify(e,i,expectTypes[s].next)}))});const incrementTypes={"++$":25,"--$":27,"$++":26,"$--":28};setLispType(["incrementerBefore"],(e,t,n,o,s,r)=>{const i=restOfExp(e,n.substring(2),[/^[^\s.\w$]/]);r.lispTree=lispify(e,n.substring(i.length+2),restOfExp.next,createLisp({op:incrementTypes[o[0]+"$"],a:lispify(e,i,expectTypes[s].next),b:0}))}),setLispType(["incrementerAfter"],(e,t,n,o,s,r)=>{r.lispTree=lispify(e,n.substring(o[0].length),expectTypes[s].next,createLisp({op:incrementTypes["$"+o[0]],a:r.lispTree,b:0}))});const adderTypes={"&&":29,"||":30,"??":89,instanceof:62,in:63,"=":9,"-=":65,"+=":66,"/=":67,"**=":68,"*=":69,"%=":70,"^=":71,"&=":72,"|=":73,">>>=":74,"<<=":76,">>=":75};setLispType(["assign","assignModify","nullishCoalescing"],(e,t,n,o,s,r)=>{r.lispTree=createLisp({op:adderTypes[o[0]],a:r.lispTree,b:lispify(e,n.substring(o[0].length),expectTypes[s].next)})}),setLispType(["boolOpOr"],(e,t,n,o,s,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse,expectTypes.splitter.types.boolOpOr],a=restOfExp(e,n.substring(o[0].length),i);r.lispTree=lispify(e,n.substring(a.length+o[0].length),restOfExp.next,createLisp({op:adderTypes[o[0]],a:r.lispTree,b:lispify(e,a,expectTypes[s].next)}))}),setLispType(["boolOpAnd"],(e,t,n,o,s,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse,expectTypes.splitter.types.boolOpAnd,expectTypes.splitter.types.boolOpOr],a=restOfExp(e,n.substring(o[0].length),i);r.lispTree=lispify(e,n.substring(a.length+o[0].length),restOfExp.next,createLisp({op:adderTypes[o[0]],a:r.lispTree,b:lispify(e,a,expectTypes[s].next)}))});const opTypes={"&":77,"|":78,"^":79,"<<":80,">>":81,">>>":82,"<=":54,">=":55,"<":56,">":57,"!==":31,"!=":53,"===":32,"==":52,"+":33,"-":47,"/":48,"**":49,"*":50,"%":51};function extractIfElse(e,t){let n,o,s=0,r=t.substring(0,0),i=emptyString,a=!0,c={};for(;(r=restOfExp(e,t.substring(r.end-t.start),[elseIf,ifElse,semiColon],void 0,void 0,void 0,c)).length||a;){a=!1;const p=t.substring(r.end-t.start).toString();if(p.startsWith("if"))r.end++,s++;else if(p.startsWith("else"))n=t.substring(0,r.end-t.start),r.end++,s--,s||r.end--;else{if(!(o=/^;?\s*else(?![\w$])/.exec(p))){n=i.length?n:t.substring(0,r.end-t.start);break}n=t.substring(0,r.end-t.start),r.end+=o[0].length-1,s--,s||(r.end-=o[0].length-1)}if(!s){i=extractIfElse(e,t.substring(r.end-t.start+(/^;?\s*else(?![\w$])/.exec(p)?.[0].length||0))).all;break}c={}}return n=n||t.substring(0,r.end-t.start),{all:t.substring(0,Math.max(n.end,i.end)-t.start),true:n,false:i}}setLispType(["opHigh","op","comparitor","bitwiseShift","bitwiseAnd","bitwiseXor","bitwiseOr"],(e,t,n,o,s,r)=>{const i=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"opHigh":i.push(expectTypes.splitter.types.opHigh);case"op":i.push(expectTypes.splitter.types.op);case"comparitor":i.push(expectTypes.splitter.types.comparitor);case"bitwiseShift":i.push(expectTypes.splitter.types.bitwiseShift);case"bitwiseAnd":i.push(expectTypes.splitter.types.bitwiseAnd);case"bitwiseXor":i.push(expectTypes.splitter.types.bitwiseXor);case"bitwiseOr":i.push(expectTypes.splitter.types.bitwiseOr),i.push(expectTypes.splitter.types.boolOpAnd),i.push(expectTypes.splitter.types.boolOpOr)}const a=restOfExp(e,n.substring(o[0].length),i);r.lispTree=lispify(e,n.substring(a.length+o[0].length),restOfExp.next,createLisp({op:opTypes[o[0]],a:r.lispTree,b:lispify(e,a,expectTypes[s].next)}))}),setLispType(["inlineIf"],(e,t,n,o,s,r)=>{let i=!1;const a=n.substring(0,0);let c=1;for(;!i&&a.length<n.length;)a.end=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]).end,"?"===n.char(a.length)?c++:c--,c||(i=!0);a.start=n.start+1,r.lispTree=createLisp({op:15,a:r.lispTree,b:createLisp({op:16,a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(o[0].length+a.length+1))})})}),setLispType(["if"],(e,t,n,o,s,r)=>{let i=restOfExp(e,n.substring(o[0].length),[],"(");const a=extractIfElse(e,n.substring(o[1].length)),c=o[0].length-o[1].length+i.length+1;let p=a.true.substring(c),l=a.false;i=i.trim(),p=p.trim(),l=l.trim(),"{"===p.char(0)&&(p=p.slice(1,-1)),"{"===l.char(0)&&(l=l.slice(1,-1)),r.lispTree=createLisp({op:13,a:lispifyExpr(e,i),b:createLisp({op:14,a:lispifyBlock(p,e),b:lispifyBlock(l,e)})})}),setLispType(["switch"],(e,t,n,o,s,r)=>{const i=restOfExp(e,n.substring(o[0].length),[],"(");let a=n.toString().indexOf("{",o[0].length+i.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,p=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const l=/^\s*(case\s|default)\s*/,d=[];let u=!1;for(;c=l.exec(p.toString());){if("default"===c[1]){if(u)throw new SyntaxError("Only one default switch case allowed");u=!0}const t=restOfExp(e,p.substring(c[0].length),[/^:/]);let n=emptyString,o=a=c[0].length+t.length+1;const s=/^\s*\{/.exec(p.substring(o).toString());let r=[];if(s)o+=s[0].length,n=restOfExp(e,p.substring(o),[],"{"),o+=n.length+1,r=lispifyBlock(n,e);else{const t=restOfExp(e,p.substring(o),[l]);if(t.trim().length){for(;(n=restOfExp(e,p.substring(o),[semiColon])).length&&(o+=n.length+(";"===p.char(o+n.length)?1:0),!l.test(p.substring(o).toString())););r=lispifyBlock(p.substring(a,n.end-p.start),e)}else r=[],o+=t.length}p=p.substring(o),d.push(createLisp({op:41,a:"default"===c[1]?0:lispifyExpr(e,t),b:r}))}r.lispTree=createLisp({op:40,a:lispifyExpr(e,i),b:d})}),setLispType(["dot","prop"],(e,t,n,o,s,r)=>{let i=o[0],a=o[0].length,c="prop";if("dot"===t){o[1]&&(c="?prop");const e=n.substring(o[0].length).toString().match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging dot");i=e[0],a=i.length+o[0].length}else if(reservedWords.has(i)&&"this"!==i)throw new SyntaxError(`Unexpected token '${i}'`);r.lispTree=lispify(e,n.substring(a),expectTypes[s].next,createLisp({op:typesCreate[c],a:r.lispTree,b:i}))}),setLispType(["spreadArray","spreadObject"],(e,t,n,o,s,r)=>{r.lispTree=createLisp({op:"spreadArray"===t?18:17,a:0,b:lispify(e,n.substring(o[0].length),expectTypes[s].next)})}),setLispType(["return","throw"],(e,t,n,o,s,r)=>{r.lispTree=createLisp({op:"return"===t?8:46,a:0,b:lispifyExpr(e,n.substring(o[0].length))})}),setLispType(["number","boolean","null","und","NaN","Infinity"],(e,t,n,o,s,r)=>{r.lispTree=lispify(e,n.substring(o[0].length),expectTypes[s].next,createLisp({op:"number"===t?o[12]?83:7:35,a:0,b:o[12]?o[1]:o[0]}))}),setLispType(["string","literal","regex"],(e,t,n,o,s,r)=>{r.lispTree=lispify(e,n.substring(o[0].length),expectTypes[s].next,createLisp({op:"string"===t?2:"literal"===t?84:85,a:0,b:o[1]}))}),setLispType(["initialize"],(e,t,n,o,s,r)=>{const i="var"===o[1]?34:"let"===o[1]?3:4;o[3]?r.lispTree=createLisp({op:i,a:o[2],b:lispify(e,n.substring(o[0].length),expectTypes[s].next)}):r.lispTree=lispify(e,n.substring(o[0].length),expectTypes[s].next,createLisp({op:i,a:o[2],b:0}))}),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],(e,t,n,o,s,r)=>{const i="function"!==t&&"inlineFunction"!==t,a=i&&!o[o.length-1],c=i?2:3,p=o[1]?88:0,l=o[c]?o[c].replace(/\s+/g,"").split(/,/g):[];i||l.unshift((o[2]||"").trimStart());let d=!1;l.forEach(e=>{if(d)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(d=!0)});const u=restOfExp(e,n.substring(o[0].length),a?[/^[,)}\]]/,semiColon]:[/^}/]),f=a?"return "+u:u.toString();l.forEach(e=>{if(reservedWords.has(e.replace(/^\.\.\./,"")))throw new SyntaxError(`Unexpected token '${e}'`)}),r.lispTree=lispify(e,n.substring(o[0].length+f.length+1),expectTypes[s].next,createLisp({op:i?11:"function"===t?37:10,a:[p,...l],b:e.eager?lispifyFunction(new CodeString(f),e):f}))});const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s+(in|of)(?![\w$])/;setLispType(["for","do","while"],(e,t,n,o,s,r)=>{let i,a,c=0,p=88,l=[],d=0,u=0,f=88,h=88;switch(t){case"while":{c=n.toString().indexOf("(")+1;const t=restOfExp(e,n.substring(c),[],"(");i=lispifyReturnExpr(e,t),a=restOfExp(e,n.substring(c+t.length+1)).trim(),"{"===a.char(0)&&(a=a.slice(1,-1));break}case"for":{c=n.toString().indexOf("(")+1;const t=[];let o,s=emptyString;for(let o=0;o<3&&(s=restOfExp(e,n.substring(c),[/^[;)]/]),t.push(s.trim()),c+=s.length+1,")"!==n.char(c-1));o++);if(1===t.length&&(o=iteratorRegex.exec(t[0].toString())))"of"===o[4]?(d=lispifyReturnExpr(e,t[0].substring(o[0].length)),l=[ofStart2,ofStart3],i=ofCondition,h=ofStep,u=lispify(e,new CodeString((o[1]||"let ")+o[3]+" = $$next.value"),["initialize"])):(d=lispifyReturnExpr(e,t[0].substring(o[0].length)),l=[inStart2,inStart3],h=inStep,i=inCondition,u=lispify(e,new CodeString((o[1]||"let ")+o[3]+" = $$keys[$$keyIndex]"),["initialize"]));else{if(3!==t.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,t.shift(),startingExecpted),i=lispifyReturnExpr(e,t.shift()),h=lispifyExpr(e,t.shift())}a=restOfExp(e,n.substring(c)).trim(),"{"===a.char(0)&&(a=a.slice(1,-1));break}case"do":{f=0;const t=!!o[3];a=restOfExp(e,n.substring(o[0].length),t?[/^\}/]:[semiColon]),i=lispifyReturnExpr(e,restOfExp(e,n.substring(n.toString().indexOf("(",o[0].length+a.length)+1),[],"("));break}}const x=[f,l,d,p,h,i,u];r.lispTree=createLisp({op:38,a:x,b:lispifyBlock(a,e)})}),setLispType(["block"],(e,t,n,o,s,r)=>{r.lispTree=createLisp({op:42,a:lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e),b:0})}),setLispType(["loopAction"],(e,t,n,o,s,r)=>{r.lispTree=createLisp({op:86,a:o[1],b:0})});const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z$_][a-zA-Z\d$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],(e,t,n,o,s,r)=>{const i=restOfExp(e,n.substring(o[0].length),[],"{");let a,c,p=catchReg.exec(n.substring(o[0].length+i.length+1).toString()),l="",d=0;p[1].startsWith("catch")?(p=catchReg.exec(n.substring(o[0].length+i.length+1).toString()),l=p[2],c=restOfExp(e,n.substring(o[0].length+i.length+1+p[0].length),[],"{"),d=o[0].length+i.length+1+p[0].length+c.length+1,(p=catchReg.exec(n.substring(d).toString()))&&p[1].startsWith("finally")&&(a=restOfExp(e,n.substring(d+p[0].length),[],"{"))):a=restOfExp(e,n.substring(o[0].length+i.length+1+p[0].length),[],"{");const u=[l,lispifyBlock(insertSemicolons(e,c||emptyString),e),lispifyBlock(insertSemicolons(e,a||emptyString),e)];r.lispTree=createLisp({op:39,a:lispifyBlock(insertSemicolons(e,i),e),b:u})}),setLispType(["void","await"],(e,t,n,o,s,r)=>{const i=restOfExp(e,n.substring(o[0].length),[/^([^\s.?\w$]|\?[^.])/]);r.lispTree=lispify(e,n.substring(o[0].length+i.length),expectTypes[s].next,createLisp({op:"void"===t?87:44,a:lispify(e,i),b:0}))}),setLispType(["new"],(e,t,n,o,s,r)=>{let i=o[0].length;const a=restOfExp(e,n.substring(i),[],void 0,"(");i+=a.length+1;const c=[];if("("===n.char(i-1)){const t=restOfExp(e,n.substring(i),[],"(");let o;i+=t.length+1;let s=0;for(;(o=restOfExp(e,t.substring(s),[/^,/])).length;)s+=o.length+1,c.push(o.trim())}r.lispTree=lispify(e,n.substring(i),expectTypes.expEdge.next,createLisp({op:45,a:lispify(e,a,expectTypes.initialize.next),b:c.map(t=>lispify(e,t,expectTypes.initialize.next))}))});const ofStart2=lispify(void 0,new CodeString("let $$iterator = $$obj[Symbol.iterator]()"),["initialize"]),ofStart3=lispify(void 0,new CodeString("let $$next = $$iterator.next()"),["initialize"]),ofCondition=lispify(void 0,new CodeString("return !$$next.done"),["initialize"]),ofStep=lispify(void 0,new CodeString("$$next = $$iterator.next()")),inStart2=lispify(void 0,new CodeString("let $$keys = Object.keys($$obj)"),["initialize"]),inStart3=lispify(void 0,new CodeString("let $$keyIndex = 0"),["initialize"]),inStep=lispify(void 0,new CodeString("$$keyIndex++")),inCondition=lispify(void 0,new CodeString("return $$keyIndex < $$keys.length"),["initialize"]);function lispify(e,t,n,o,s=!1){if(o=o||NullLisp,n=n||expectTypes.initialize.next,void 0===t)return o;const r=(t=t.trimStart()).toString();if(!t.length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t.length)return o;const i={lispTree:o};let a;for(const o of n)if("expEnd"!==o){for(const n in expectTypes[o].types)if("expEnd"!==n&&(a=expectTypes[o].types[n].exec(r))){lastType=n;try{lispTypes.get(n)?.(e,n,t,a,o,i)}catch(e){if(s&&e instanceof SyntaxError)throw new ParseError(e.message,r);throw e}break}if(a)break}if(!a&&t.length){if(s)throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`,r);throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`)}return i.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter(e=>"expSingle"!==e);function lispifyExpr(e,t,n){if(!t.trimStart().length)return NullLisp;const o=[];let s,r=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t.toString(),Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);(s=restOfExp(e,t.substring(r),[/^,/])).length;)o.push(s.trimStart()),r+=s.length+1;if(1===o.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){const s=expectTypes.initialize.types.initialize.exec(o[0].toString());if(s)return createLisp({op:42,a:o.map((t,n)=>lispify(e,n?new CodeString(s[1]+" "+t):t,["initialize"],void 0,!0)),b:0});if(expectTypes.initialize.types.return.exec(o[0].toString()))return lispify(e,t,n,void 0,!0)}const i=o.map(t=>lispify(e,t,n,void 0,!0));return createLisp({op:43,a:i,b:0})}function lispifyReturnExpr(e,t){return createLisp({op:8,a:0,b:lispifyExpr(e,t)})}function lispifyBlock(e,t,n=!1){if(!(e=insertSemicolons(t,e)).trim().length)return[];const o=[];let s,r=0,i=0,a={},c=!1,p=!1;for(;(s=restOfExp(t,e.substring(r),[semiColon],void 0,void 0,void 0,a)).length&&(p=!(!e.char(r+s.length)||";"===e.char(r+s.length)),r+=s.length+(p?0:1),/^\s*else(?![\w$])/.test(e.substring(r).toString())||a.words?.includes("do")&&/^\s*while(?![\w$])/.test(e.substring(r).toString())?c=!0:(c=!1,o.push(e.substring(i,r-(p?0:1))),i=r),a={},!n););return c&&o.push(e.substring(i,r-(p?0:1))),o.map(e=>e.trimStart()).filter(e=>e.length).map(e=>lispifyExpr(t,e.trimStart(),startingExecpted))}function lispifyFunction(e,t,n=!1){if(!e.trim().length)return[];const o=lispifyBlock(e,t,n);return hoist(o),o}function hoist(e,t=[]){if(isLisp(e)){if(!isLisp(e))return!1;const[n,o,s]=e;if(39===n||13===n||38===n||40===n)hoist(o,t),hoist(s,t);else if(34===n)t.push(createLisp({op:34,a:o,b:0}));else if(37===n&&o[1])return t.push(e),!0}else if(Array.isArray(e)){const n=[];for(const o of e)hoist(o,t)||n.push(o);n.length!==e.length&&(e.length=0,e.push(...t,...n))}return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w$])/,colonsRegex=/^((([\w$\])"'`]|\+\+|--)\s*\r?\n\s*([\w$+\-!~]))|(\}\s*[\w$!~+\-{("'`]))/;function insertSemicolons(e,t){let n=t,o=emptyString,s={};const r=insertedSemicolons.get(t.ref)||new Array(t.ref.str.length);for(;(o=restOfExp(e,n,[],void 0,void 0,[colonsRegex],s)).length;){let e=!1,t=o,i=o.length;if(s.regRes){e=!0;const[,,r,,,a]=s.regRes;if(i="++"===s.regRes[3]||"--"===s.regRes[3]?o.length+1:o.length,t=n.substring(0,i),a){const t=closingsNoInsertion.exec(n.substring(o.length-1).toString());t?e="while"===t[2]&&"do"!==s.lastWord:"function"===s.lastWord&&"}"===s.regRes[5][0]&&"("===s.regRes[5].slice(-1)&&(e=!1)}else r&&("if"!==s.lastWord&&"while"!==s.lastWord&&"for"!==s.lastWord&&"else"!==s.lastWord||(e=!1))}e&&(r[t.end]=!0),n=n.substring(i),s={}}return insertedSemicolons.set(t.ref,r),t}function checkRegex(e){let t=1,n=!1,o=!1,s=!1;for(;t<e.length&&!o&&!s;)o="/"===e[t]&&!n,n="\\"===e[t]&&!n,s="\n"===e[t],t++;const r=e.substring(t);if(s=s||!o||/^\s*\d/.test(r),s)return null;const i=/^[a-z]*/.exec(r);return/^\s+[\w$]/.test(e.substring(t+i[0].length))?null:{regex:e.substring(1,t-1),flags:i&&i[0]||"",length:t+(i&&i[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w$\])]|\+\+|--)[\s/]/;function extractConstants(e,t,n=""){let o,s,r=[],i=!1,a="",c=-1,p=[],l="";const d=[],u=[];let f=null,h=0;for(h=0;h<t.length;h++)if(l=t[h],a)l===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(i){i=!1,r.push(l);continue}if(o)if("`"===o&&"$"===l&&"{"===t[h+1]){const n=extractConstants(e,t.substring(h+2),"{");p.push(n.str),r.push("${",p.length-1,"}"),h+=n.length+2}else if(o===l){if("`"===o){const t=createLisp({op:36,a:unraw(r.join("")),b:[]});t.tempJsStrings=p,e.literals.push(t),d.push("`",e.literals.length-1,"`")}else e.strings.push(unraw(r.join(""))),d.push('"',e.strings.length-1,'"');o=null,r=[]}else r.push(l);else{if("'"===l||'"'===l||"`"===l)p=[],o=l;else{if(closings[n]===l&&!u.length)return{str:d.join(""),length:h};closings[l]?(u.push(l),d.push(l)):closings[u[u.length-1]]===l?(u.pop(),d.push(l)):"/"!==l||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===l&&!f&&(s=checkRegex(t.substring(h)))?(e.regexes.push(s),d.push("/",e.regexes.length-1,"/r"),h+=s.length-1):d.push(l):(a="*"===t[h+1]?"*":"\n",c=h)}f&&space.test(l)||(f=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+f[1].length))&&(f=null)}i=!(!o||"\\"!==l)}if(a&&"*"===a)throw new SyntaxError(`Unclosed comment '/*': ${t.substring(c)}`);return{str:d.join(""),length:h}}function parse(e,t=!1,n=!1){if("string"!=typeof e)throw new ParseError(`Cannot parse ${e}`,e);let o=" "+e;const s={strings:[],literals:[],regexes:[],eager:t};o=extractConstants(s,o).str;for(const e of s.literals)e[2]=e.tempJsStrings.map(e=>lispifyExpr(s,new CodeString(e))),delete e.tempJsStrings;return{tree:lispifyFunction(new CodeString(o),s,n),constants:s}}function createEvalContext(){return{sandboxFunction,sandboxAsyncFunction,sandboxedEval,sandboxedSetTimeout,sandboxedSetInterval,sandboxedClearTimeout,sandboxedClearInterval,lispifyFunction}}function sandboxFunction(e,t){return function(...n){const o=parse(n.pop()||"");return createFunction(n,o.tree,t||currentTicks.current,{...e,constants:o.constants,tree:o.tree},void 0,"anonymous")}}function sandboxAsyncFunction(e,t){return function(...n){const o=parse(n.pop()||"");return createFunctionAsync(n,o.tree,t||currentTicks.current,{...e,constants:o.constants,tree:o.tree},void 0,"anonymous")}}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e,t){return function(n,o,...s){const r=t.ctx.sandbox,i=(...t)=>{const o="string"==typeof n?e(n):n;return d.unsubscribe(),u.unsubscribe(),r.setTimeoutHandles.delete(a),o(...t)},a=++r.timeoutHandleCounter;let c=Date.now(),p=setTimeout(i,o,...s),l=0;const d=r.subscribeHalt(()=>{l=Date.now()-c+l,clearTimeout(p)}),u=r.subscribeResume(()=>{c=Date.now();const e=Math.floor((o||0)-l);p=setTimeout(i,e,...s),r.setTimeoutHandles.set(a,{handle:p,haltsub:d,contsub:u})});return r.setTimeoutHandles.set(a,{handle:p,haltsub:d,contsub:u}),a}}function sandboxedClearTimeout(e){return function(t){const n=e.ctx.sandbox,o=n.setTimeoutHandles.get(t);o&&(clearTimeout(o.handle),o.haltsub.unsubscribe(),o.contsub.unsubscribe(),n.setTimeoutHandles.delete(t))}}function sandboxedClearInterval(e){return function(t){const n=e.ctx.sandbox,o=n.setIntervalHandles.get(t);o&&(clearInterval(o.handle),o.haltsub.unsubscribe(),o.contsub.unsubscribe(),n.setIntervalHandles.delete(t))}}function sandboxedSetInterval(e,t){return function(n,o,...s){const r=t.ctx.sandbox,i="string"==typeof n?e(n):n,a=(...e)=>(p=Date.now(),d=0,i(...e)),c=++r.timeoutHandleCounter;let p=Date.now(),l=setInterval(a,o,...s),d=0;const u=r.subscribeHalt(()=>{d=Date.now()-p+d,clearInterval(l)}),f=r.subscribeResume(()=>{p=Date.now(),l=setTimeout(()=>{p=Date.now(),d=0,l=setInterval(a,o,...s),a(...s)},Math.floor((o||0)-d),...s),h.handle=l}),h={handle:l,haltsub:u,contsub:f};return r.setIntervalHandles.set(c,h),c}}function subscribeSet(e,t,n,o){const s=o.setSubscriptions.get(e)||new Map;o.setSubscriptions.set(e,s);const r=s.get(t)||new Set;let i;s.set(t,r),r.add(n);const a=e[t];return a instanceof Object&&(i=o.changeSubscriptions.get(a)||new Set,i.add(n),o.changeSubscriptions.set(a,i)),{unsubscribe:()=>{r.delete(n),i?.delete(n)}}}class SandboxExec{constructor(e,t){this.evalContext=t,this.setSubscriptions=new WeakMap,this.changeSubscriptions=new WeakMap,this.sandboxFunctions=new WeakMap,this.haltSubscriptions=new Set,this.resumeSubscriptions=new Set,this.halted=!1,this.timeoutHandleCounter=0,this.setTimeoutHandles=new Map,this.setIntervalHandles=new Map;const n=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:SandboxExec.SAFE_GLOBALS,prototypeWhitelist:SandboxExec.SAFE_PROTOTYPES,prototypeReplacements:new Map},e||{});this.context=createContext(this,n)}static get SAFE_GLOBALS(){return{globalThis,Function,eval,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,escape,unescape,Boolean,Number,BigInt,String,Object,Array,Symbol,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Intl,JSON,Math,Date,RegExp}}static get SAFE_PROTOTYPES(){const e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach(e=>{t.set(e,new Set)}),t.set(Object,new Set(["constructor","name","entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e,t){return t.getSubscriptions.add(e),{unsubscribe:()=>t.getSubscriptions.delete(e)}}subscribeSet(e,t,n,o){return subscribeSet(e,t,n,o)}subscribeSetGlobal(e,t,n){return subscribeSet(e,t,n,this)}subscribeHalt(e){return this.haltSubscriptions.add(e),{unsubscribe:()=>{this.haltSubscriptions.delete(e)}}}subscribeResume(e){return this.resumeSubscriptions.add(e),{unsubscribe:()=>{this.resumeSubscriptions.delete(e)}}}haltExecution(e){if(!this.halted){this.halted=!0;for(const t of this.haltSubscriptions)t(e)}}resumeExecution(){if(this.halted){if(this.context.ticks.tickLimit&&this.context.ticks.ticks>=this.context.ticks.tickLimit)throw new SandboxExecutionQuotaExceededError("Cannot resume execution: tick limit exceeded");this.halted=!1;for(const e of this.resumeSubscriptions)e()}}getContext(e){return this.sandboxFunctions.get(e)}executeTree(e,t=[]){return executeTree(e.ctx.ticks,e,e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync(e.ctx.ticks,e,e.tree,t)}}class Sandbox extends SandboxExec{constructor(e){super(e,createEvalContext())}static audit(e,t=[]){const n={};for(const e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];const o=new SandboxExec({globals:n,audit:!0});return o.executeTree(createExecContext(o,parse(e,!0),createEvalContext()),t)}static parse(e){return parse(e)}compile(e,t=!1){const n=parse(e,t);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileAsync(e,t=!1){const n=parse(e,t);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}compileExpression(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileExpressionAsync(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=createExecContext(this,n,this.evalContext);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then(e=>e.result)}}}}const{eventSource,event_types,executeSlashCommands}=SillyTavern.getContext(),events=[event_types.CHARACTER_MESSAGE_RENDERED,event_types.USER_MESSAGE_RENDERED,event_types.CHAT_CHANGED,event_types.MESSAGE_SWIPED];events.push("MESSAGE_UPDATED"in event_types?event_types.MESSAGE_UPDATED:event_types.MESSAGE_EDITED);const clearedSymbol=Symbol("cancel"),supportedLanguages=["language-javascript","language-stscript"];for(const e of events)eventSource.on(e,addExecuteButtonToCodeBlocks);function addExecuteButtonToCodeBlocks(){const e=Array.from(document.querySelectorAll("#chat .mes_text pre code"));for(const t of e)if(!t.classList.contains("code-runner")&&supportedLanguages.some(e=>t.classList.contains(e))){const e=t.className.match(/language-(\w+)/)[1];addExecuteButton(t,e),t.classList.add("code-runner")}}function addExecuteButton(e,t){const n=document.createElement("i");n.title="Run code",n.classList.add("code-runner-button","fa-solid","fa-play"),n.addEventListener("click",()=>{"javascript"===t&&runJavaScriptCode(e),"stscript"===t&&runSTScriptCode(e)}),e.appendChild(n)}function getOutputElement(e){let t=e.parentElement.querySelector(".code-output");t||(t=document.createElement("blockquote"),t.classList.add("code-output"),e.parentElement.appendChild(t)),t.innerHTML="";const n=document.createElement("i");n.classList.add("code-output-hourglass","fa-solid","fa-hourglass","fa-2x"),n.style.display="none";const o=document.createElement("i");o.classList.add("code-output-clear","fa-solid","fa-xmark","fa-fw"),o.title="Clear output",o.onclick=()=>{t.remove()},t.appendChild(o),t.appendChild(n);const s=new Promise(e=>{o.addEventListener("click",()=>e(clearedSymbol),{once:!0})});return{outputElement:t,clearClicked:s}}function showLoader(e){const t=e.querySelector(".code-output-hourglass");t&&(t.style.display="block")}function hideLoader(e){const t=e.querySelector(".code-output-hourglass");t&&(t.style.display="none")}class CustomConsole{constructor(e){this.#e(),this.outputElement=e}#e(){for(const e of Object.keys(console))"function"!=typeof console[e]||this[e]||(this[e]=()=>{})}#t(e){const t=document.createElement("div"),n=e.reduce((e,t)=>"object"==typeof t?e+JSON.stringify(t)+" ":e+String(t)+" ","");t.textContent=n,this.outputElement.appendChild(t)}info(...e){this.#t(e)}log(...e){this.#t(e)}error(...e){this.#t(e)}warn(...e){this.#t(e)}debug(...e){this.#t(e)}table(...e){this.#t(e)}trace(...e){this.#t(e)}alert(...e){this.#t(e)}addResult(e,t){const n=document.createElement("div"),o=document.createElement("small"),s=(t/1e3).toFixed(2);o.textContent=`Finished in ${s} sec. Result: ${JSON.stringify(e)}`,n.appendChild(o),this.outputElement.appendChild(n)}}async function runJavaScriptCode(e){try{const{outputElement:t,clearClicked:n}=getOutputElement(e);showLoader(t);const o=new CustomConsole(t),s=e.textContent,r=Sandbox.SAFE_PROTOTYPES;r.set(CustomConsole,new Set);const i={...Sandbox.SAFE_GLOBALS,alert:o.alert.bind(o),console:o,setTimeout,clearTimeout,setInterval,clearInterval},a=new Sandbox({globals:i,prototypeWhitelist:r}),c={},p=a.compileAsync(s),l=Date.now(),d=await Promise.race([p(c).run(),n]),u=Date.now();if(hideLoader(t),d===clearedSymbol)return;o.addResult(d,u-l)}catch(e){console.error("Error running code",e),toastr.error("Error running code",e.message)}}async function runSTScriptCode(e){try{const{outputElement:t,clearClicked:n}=getOutputElement(e),o=e.textContent,s=new AbortController,r=new CustomConsole(t);showLoader(t);const i=Date.now(),a=executeSlashCommands(o,!0,null,!1,null,s,(e,t)=>{}),c=await Promise.race([a,n]);if(hideLoader(t),c===clearedSymbol)return void s.abort();const p=Date.now();r.addResult(c?.pipe,p-i)}catch(e){console.error("Error running code",e),toastr.error("Error running code",e.message)}}})();