(()=>{"use strict";var __webpack_modules__={208:(e,t,n)=>{n.d(t,{A:()=>a});var r=n(601),s=n.n(r),i=n(314),o=n.n(i)()(s());o.push([e.id,".code-runner-button {\n    cursor: pointer;\n    position: absolute;\n    bottom: 0;\n    right: 0;\n    height: 22px;\n    width: 22px;\n    margin: 4px;\n    opacity: 0.4;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n}\n\n.code-runner-button:hover,\n.code-output-clear:hover {\n    opacity: 0.8;\n}\n\n.code-output {\n    position: relative;\n    width: 100%;\n    overflow-y: auto;\n    max-height: 25vh;\n    max-height: 25svh;\n    min-height: 3em;\n}\n\n.code-output > div {\n    font-size: calc(var(--mainFontSize) * 0.9);\n}\n\n.code-output-hourglass {\n    position: absolute;\n    bottom: 50%;\n    left: 50%;\n    transform: translate(-50%, 50%);\n    opacity: 0.5;\n}\n\n.code-output-clear {\n    position: absolute;\n    top: 0;\n    right: 0;\n    margin: 4px;\n    opacity: 0.4;\n    cursor: pointer;\n}\n",""]);const a=o},314:e=>{e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,s,i){"string"==typeof e&&(e=[[null,e,void 0]]);var o={};if(r)for(var a=0;a<this.length;a++){var c=this[a][0];null!=c&&(o[c]=!0)}for(var l=0;l<e.length;l++){var p=[].concat(e[l]);r&&o[p[0]]||(void 0!==i&&(void 0===p[5]||(p[1]="@layer".concat(p[5].length>0?" ".concat(p[5]):""," {").concat(p[1],"}")),p[5]=i),n&&(p[2]?(p[1]="@media ".concat(p[2]," {").concat(p[1],"}"),p[2]=n):p[2]=n),s&&(p[4]?(p[1]="@supports (".concat(p[4],") {").concat(p[1],"}"),p[4]=s):p[4]="".concat(s)),t.push(p))}},t}},601:e=>{e.exports=function(e){return e[1]}},72:e=>{var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var i={},o=[],a=0;a<e.length;a++){var c=e[a],l=r.base?c[0]+r.base:c[0],p=i[l]||0,d="".concat(l," ").concat(p);i[l]=p+1;var u=n(d),f={css:c[1],media:c[2],sourceMap:c[3],supports:c[4],layer:c[5]};if(-1!==u)t[u].references++,t[u].updater(f);else{var h=s(f,r);r.byIndex=a,t.splice(a,0,{identifier:d,updater:h,references:1})}o.push(d)}return o}function s(e,t){var n=t.domAPI(t);n.update(e);return function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,s){var i=r(e=e||[],s=s||{});return function(e){e=e||[];for(var o=0;o<i.length;o++){var a=n(i[o]);t[a].references--}for(var c=r(e,s),l=0;l<i.length;l++){var p=n(i[l]);0===t[p].references&&(t[p].updater(),t.splice(p,1))}i=c}}},659:e=>{var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},540:e=>{e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},56:(e,t,n)=>{e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},825:e=>{e.exports=function(e){if("undefined"==typeof document)return{update:function(){},remove:function(){}};var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var s=void 0!==n.layer;s&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,s&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var i=n.sourceMap;i&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(i))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},113:e=>{e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={id:e,exports:{}};return __webpack_modules__[e](n,n.exports,__webpack_require__),n.exports}__webpack_require__.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return __webpack_require__.d(t,{a:t}),t},__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.nc=void 0;var __webpack_exports__={};(()=>{var injectStylesIntoStyleTag=__webpack_require__(72),injectStylesIntoStyleTag_default=__webpack_require__.n(injectStylesIntoStyleTag),styleDomAPI=__webpack_require__(825),styleDomAPI_default=__webpack_require__.n(styleDomAPI),insertBySelector=__webpack_require__(659),insertBySelector_default=__webpack_require__.n(insertBySelector),setAttributesWithoutAttributes=__webpack_require__(56),setAttributesWithoutAttributes_default=__webpack_require__.n(setAttributesWithoutAttributes),insertStyleElement=__webpack_require__(540),insertStyleElement_default=__webpack_require__.n(insertStyleElement),styleTagTransform=__webpack_require__(113),styleTagTransform_default=__webpack_require__.n(styleTagTransform),style=__webpack_require__(208),options={};options.styleTagTransform=styleTagTransform_default(),options.setAttributes=setAttributesWithoutAttributes_default(),options.insert=insertBySelector_default().bind(null,"head"),options.domAPI=styleDomAPI_default(),options.insertStyleElement=insertStyleElement_default();var update=injectStylesIntoStyleTag_default()(style.A,options);const src_style=style.A&&style.A.locals?style.A.locals:void 0;function parseHexToInt(e){return e.match(/[^a-f0-9]/i)?NaN:parseInt(e,16)}function validateAndParseHex(e,t,n){const r=parseHexToInt(e);if(Number.isNaN(r)||void 0!==n&&n!==e.length)throw new SyntaxError(t+": "+e);return r}function parseHexadecimalCode(e){const t=validateAndParseHex(e,"Malformed Hexadecimal",2);return String.fromCharCode(t)}function parseUnicodeCode(e,t){const n=validateAndParseHex(e,"Malformed Unicode",4);if(void 0!==t){const e=validateAndParseHex(t,"Malformed Unicode",4);return String.fromCharCode(n,e)}return String.fromCharCode(n)}function isCurlyBraced(e){return"{"===e.charAt(0)&&"}"===e.charAt(e.length-1)}function parseUnicodeCodePointCode(e){if(!isCurlyBraced(e))throw new SyntaxError("Malformed Unicode: +"+e);const t=validateAndParseHex(e.slice(1,-1),"Malformed Unicode");try{return String.fromCodePoint(t)}catch(e){throw e instanceof RangeError?new SyntaxError("Code Point Limit:"+t):e}}const singleCharacterEscapes=new Map([["b","\b"],["f","\f"],["n","\n"],["r","\r"],["t","\t"],["v","\v"],["0","\0"]]);function parseSingleCharacterCode(e){return singleCharacterEscapes.get(e)||e}const escapeMatch=/\\(?:(\\)|x([\s\S]{0,2})|u(\{[^}]*\}?)|u([\s\S]{4})\\u([^{][\s\S]{0,3})|u([\s\S]{0,4})|([0-3]?[0-7]{1,2})|([\s\S])|$)/g;function unraw(e){return e.replace(escapeMatch,(function(e,t,n,r,s,i,o,a,c){if(void 0!==t)return"\\";if(void 0!==n)return parseHexadecimalCode(n);if(void 0!==r)return parseUnicodeCodePointCode(r);if(void 0!==s)return parseUnicodeCode(s,i);if(void 0!==o)return parseUnicodeCode(o);if("0"===a)return"\0";if(void 0!==a)throw new SyntaxError("Octal Deprecation: "+a);if(void 0!==c)return parseSingleCharacterCode(c);throw new SyntaxError("End of string")}))}function createLisp(e){return[e.op,e.a,e.b]}let lispTypes=new Map;class ParseError extends Error{constructor(e,t){super(e+": "+t.substring(0,40)),this.code=t}}const inlineIfElse=/^:/,elseIf=/^else(?![\w\$])/,ifElse=/^if(?![\w\$])/,space=/^\s/;let expectTypes={splitter:{types:{opHigh:/^(\/|\*\*|\*(?!\*)|\%)(?!\=)/,op:/^(\+(?!(\+))|\-(?!(\-)))(?!\=)/,comparitor:/^(<=|>=|<(?!<)|>(?!>)|!==|!=(?!\=)|===|==)/,boolOp:/^(&&|\|\||instanceof(?![\w\$])|in(?![\w\$]))/,bitwise:/^(&(?!&)|\|(?!\|)|\^|<<|>>(?!>)|>>>)(?!\=)/},next:["modifier","value","prop","incrementerBefore"]},inlineIf:{types:{inlineIf:/^\?(?!\.(?!\d))/},next:["expEnd"]},assignment:{types:{assignModify:/^(\-=|\+=|\/=|\*\*=|\*=|%=|\^=|\&=|\|=|>>>=|>>=|<<=)/,assign:/^(=)(?!=)/},next:["modifier","value","prop","incrementerBefore"]},incrementerBefore:{types:{incrementerBefore:/^(\+\+|\-\-)/},next:["prop"]},expEdge:{types:{call:/^(\?\.)?[\(]/,incrementerAfter:/^(\+\+|\-\-)/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},modifier:{types:{not:/^!/,inverse:/^~/,negative:/^\-(?!\-)/,positive:/^\+(?!\+)/,typeof:/^typeof(?![\w\$])/,delete:/^delete(?![\w\$])/},next:["modifier","value","prop","incrementerBefore"]},dot:{types:{arrayProp:/^(\?\.)?\[/,dot:/^(\?)?\.(?=\s*[a-zA-Z\$\_])/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},prop:{types:{prop:/^[a-zA-Z\$\_][a-zA-Z\d\$\_]*/},next:["splitter","assignment","expEdge","dot","inlineIf","expEnd"]},value:{types:{createObject:/^\{/,createArray:/^\[/,number:/^(0x[\da-f]+(_[\da-f]+)*|(\d+(_\d+)*(\.\d+(_\d+)*)?|\.\d+(_\d+)*))(e[\+\-]?\d+(_\d+)*)?(n)?(?!\d)/i,string:/^"(\d+)"/,literal:/^`(\d+)`/,regex:/^\/(\d+)\/r(?![\w\$])/,boolean:/^(true|false)(?![\w\$])/,null:/^null(?![\w\$])/,und:/^undefined(?![\w\$])/,arrowFunctionSingle:/^(async\s+)?([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*=>\s*({)?/,arrowFunction:/^(async\s*)?\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*=>\s*({)?/,inlineFunction:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)?\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/,group:/^\(/,NaN:/^NaN(?![\w\$])/,Infinity:/^Infinity(?![\w\$])/,void:/^void(?![\w\$])\s*/,await:/^await(?![\w\$])\s*/,new:/^new(?![\w\$])\s*/},next:["splitter","expEdge","dot","inlineIf","expEnd"]},initialize:{types:{initialize:/^(var|let|const)\s+([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*(=)?/,return:/^return(?![\w\$])/,throw:/^throw(?![\w\$])\s*/},next:["modifier","value","prop","incrementerBefore","expEnd"]},spreadObject:{types:{spreadObject:/^\.\.\./},next:["value","prop"]},spreadArray:{types:{spreadArray:/^\.\.\./},next:["value","prop"]},expEnd:{types:{},next:[]},expFunction:{types:{function:/^(async\s+)?function(\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\(\s*((\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*(\s*,\s*(\.\.\.)?\s*[a-zA-Z\$_][a-zA-Z\d\$_]*)*)?\s*\)\s*{/},next:["expEdge","expEnd"]},expSingle:{types:{for:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*for\s*\(/,do:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*do(?![\w\$])\s*(\{)?/,while:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*while\s*\(/,loopAction:/^(break|continue)(?![\w\$])\s*([a-zA-Z\$\_][\w\$]*)?/,if:/^((([a-zA-Z\$\_][\w\$]*)\s*:)?\s*)if\s*\(/,try:/^try\s*{/,block:/^{/,switch:/^(([a-zA-Z\$\_][\w\$]*)\s*:)?\s*switch\s*\(/},next:["expEnd"]}},closings={"(":")","[":"]","{":"}","'":"'",'"':'"',"`":"`"};function testMultiple(e,t){let n;for(let r=0;r<t.length&&(n=t[r].exec(e),!n);r++);return n}class CodeString{constructor(e){this.ref={str:""},e instanceof CodeString?(this.ref=e.ref,this.start=e.start,this.end=e.end):(this.ref.str=e,this.start=0,this.end=e.length)}substring(e,t){if(!this.length)return this;(e=this.start+e)<0&&(e=0),e>this.end&&(e=this.end),(t=void 0===t?this.end:this.start+t)<0&&(t=0),t>this.end&&(t=this.end);const n=new CodeString(this);return n.start=e,n.end=t,n}get length(){const e=this.end-this.start;return e<0?0:e}char(e){if(this.start!==this.end)return this.ref.str[this.start+e]}toString(){return this.ref.str.substring(this.start,this.end)}trimStart(){const e=/^\s+/.exec(this.toString()),t=new CodeString(this);return e&&(t.start+=e[0].length),t}slice(e,t){return e<0&&(e=this.end-this.start+e),e<0&&(e=0),void 0===t&&(t=this.end-this.start),t<0&&(t=this.end-this.start+t),t<0&&(t=0),this.substring(e,t)}trim(){const e=this.trimStart(),t=/\s+$/.exec(e.toString());return t&&(e.end-=t[0].length),e}valueOf(){return this.toString()}}const emptyString=new CodeString(""),okFirstChars=/^[\+\-~ !]/,aNumber=expectTypes.value.types.number,wordReg=/^((if|for|else|while|do|function)(?![\w\$])|[\w\$]+)/,semiColon=/^;/,insertedSemicolons=new WeakMap,quoteCache=new WeakMap;function restOfExp(e,t,n,r,s,i,o={}){if(!t.length)return t;o.words=o.words||[];let a=!0;const c=(n=n||[]).includes(semiColon);c&&(n=n.filter((e=>e!==semiColon)));const l=insertedSemicolons.get(t.ref)||[],p=quoteCache.get(t.ref)||new Map;if(quoteCache.set(t.ref,p),r&&p.has(t.start-1))return t.substring(0,p.get(t.start-1)-t.start);let d,u=!1,f=!1,h="",g=!1,y=!1;for(d=0;d<t.length&&!f;d++){let x=t.char(d);if('"'===r||"'"===r||"`"===r){if("`"!==r||"$"!==x||"{"!==t.char(d+1)||u){if(x===r&&!u)return t.substring(0,d)}else d+=restOfExp(e,t.substring(d+2),[],"{").length+2;u=!u&&"\\"===x}else if(closings[x]){if(!y&&l[d+t.start]){if(y=!0,c)break;d--,h=";";continue}if(g&&"{"===x&&(g=!1),x===s){f=!0;break}{let n=restOfExp(e,t.substring(d+1),[],x);if(p.set(n.start-1,n.end),d+=n.length+1,a=!1,i){let e;(e=testMultiple(t.substring(d).toString(),i))&&(o.regRes=e,f=!0)}}}else if(r){if(x===closings[r])return t.substring(0,d)}else{let e,r,s=t.substring(d).toString();if(i){let e;if(e=testMultiple(s,i)){o.regRes=e,d++,f=!0;break}}if(r=aNumber.exec(s))d+=r[0].length-1,s=t.substring(d).toString();else if(h!=x){let r;if(";"===x||l[d+t.start]&&!a&&!y){if(c)r=[";"];else if(l[d+t.start]){y=!0,d--,h=";";continue}x=s=";"}else y=!1;r||(r=testMultiple(s,n)),r&&(f=!0),!f&&(e=wordReg.exec(s))&&(g=!0,e[0].length>1&&(o.words.push(e[1]),o.lastAnyWord=e[1],e[2]&&(o.lastWord=e[2])),e[0].length>2&&(d+=e[0].length-2))}if(a&&(okFirstChars.test(s)?f=!1:a=!1),f)break}h=x}if(r)throw new SyntaxError("Unclosed '"+r+"'");return o&&(o.oneliner=g),t.substring(0,d)}restOfExp.next=["splitter","expEnd","inlineIf"];const startingExecpted=["initialize","expSingle","expFunction","value","modifier","prop","incrementerBefore","expEnd"],setLispType=(e,t)=>{e.forEach((e=>{lispTypes.set(e,t)}))},closingsCreate={createArray:/^\]/,createObject:/^\}/,group:/^\)/,arrayProp:/^\]/,call:/^\)/},typesCreate={createArray:12,createObject:22,group:23,arrayProp:19,call:5,prop:1,"?prop":20,"?call":21};setLispType(["createArray","createObject","group","arrayProp","call"],((e,t,n,r,s,i)=>{let o=emptyString,a=[],c=!1,l=r[0].length;const p=l;for(;l<n.length&&!c;)o=restOfExp(e,n.substring(l),[closingsCreate[t],/^,/]),l+=o.length,o.trim().length&&a.push(o),","!==n.char(l)?c=!0:l++;const d=["value","modifier","prop","incrementerBefore","expEnd"];let u,f;switch(t){case"group":case"arrayProp":u=lispifyExpr(e,n.substring(p,l));break;case"call":case"createArray":u=a.map((t=>lispify(e,t,[...d,"spreadArray"])));break;case"createObject":u=a.map((t=>{let n;t=t.trimStart();let r="";if(f=expectTypes.expFunction.types.function.exec("function "+t),f)r=f[2].trimStart(),n=lispify(e,new CodeString("function "+t.toString().replace(r,"")));else{let s=restOfExp(e,t,[/^:/]);r=lispify(e,s,[...d,"spreadObject"]),1===r[0]&&(r=r[2]),n=lispify(e,t.substring(s.length+1))}return createLisp({op:6,a:r,b:n})}))}let h="arrayProp"===t?r[1]?20:1:"call"===t?r[1]?21:5:typesCreate[t];i.lispTree=lispify(e,n.substring(l+1),expectTypes[s].next,createLisp({op:h,a:i.lispTree,b:u}))}));const modifierTypes={inverse:64,not:24,positive:59,negative:58,typeof:60,delete:61};setLispType(["inverse","not","negative","positive","typeof","delete"],((e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(r[0].length),[/^([^\s\.\?\w\$]|\?[^\.])/]);i.lispTree=lispify(e,n.substring(o.length+r[0].length),restOfExp.next,createLisp({op:modifierTypes[t],a:i.lispTree,b:lispify(e,o,expectTypes[s].next)}))}));const incrementTypes={"++$":25,"--$":27,"$++":26,"$--":28};setLispType(["incrementerBefore"],((e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(2),[/^[^\s\.\w\$]/]);i.lispTree=lispify(e,n.substring(o.length+2),restOfExp.next,createLisp({op:incrementTypes[r[0]+"$"],a:lispify(e,o,expectTypes[s].next),b:0}))})),setLispType(["incrementerAfter"],((e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,createLisp({op:incrementTypes["$"+r[0]],a:i.lispTree,b:0}))}));const adderTypes={"&&":29,"||":30,instanceof:62,in:63,"=":9,"-=":65,"+=":66,"/=":67,"**=":68,"*=":69,"%=":70,"^=":71,"&=":72,"|=":73,">>>=":74,"<<=":76,">>=":75};setLispType(["assign","assignModify","boolOp"],((e,t,n,r,s,i)=>{i.lispTree=createLisp({op:adderTypes[r[0]],a:i.lispTree,b:lispify(e,n.substring(r[0].length),expectTypes[s].next)})}));const opTypes={"&":77,"|":78,"^":79,"<<":80,">>":81,">>>":82,"<=":54,">=":55,"<":56,">":57,"!==":31,"!=":53,"===":32,"==":52,"+":33,"-":47,"/":48,"**":49,"*":50,"%":51};function extractIfElse(e,t){let n,r,s=0,i=t.substring(0,0),o=emptyString,a=!0,c={};for(;(i=restOfExp(e,t.substring(i.end-t.start),[elseIf,ifElse,semiColon],void 0,void 0,void 0,c)).length||a;){a=!1;const l=t.substring(i.end-t.start).toString();if(l.startsWith("if"))i.end++,s++;else if(l.startsWith("else"))n=t.substring(0,i.end-t.start),i.end++,s--,s||i.end--;else{if(!(r=/^;?\s*else(?![\w\$])/.exec(l))){n=o.length?n:t.substring(0,i.end-t.start);break}n=t.substring(0,i.end-t.start),i.end+=r[0].length-1,s--,s||(i.end-=r[0].length-1)}if(!s){o=extractIfElse(e,t.substring(i.end-t.start+/^;?\s*else(?![\w\$])/.exec(l)?.[0].length)).all;break}c={}}return n=n||t.substring(0,i.end-t.start),{all:t.substring(0,Math.max(n.end,o.end)-t.start),true:n,false:o}}setLispType(["opHigh","op","comparitor","bitwise"],((e,t,n,r,s,i)=>{const o=[expectTypes.inlineIf.types.inlineIf,inlineIfElse];switch(t){case"opHigh":o.push(expectTypes.splitter.types.opHigh);case"op":o.push(expectTypes.splitter.types.op);case"comparitor":o.push(expectTypes.splitter.types.comparitor);case"bitwise":o.push(expectTypes.splitter.types.bitwise),o.push(expectTypes.splitter.types.boolOp)}let a=restOfExp(e,n.substring(r[0].length),o);i.lispTree=lispify(e,n.substring(a.length+r[0].length),restOfExp.next,createLisp({op:opTypes[r[0]],a:i.lispTree,b:lispify(e,a,expectTypes[s].next)}))})),setLispType(["inlineIf"],((e,t,n,r,s,i)=>{let o=!1,a=n.substring(0,0),c=1;for(;!o&&a.length<n.length;)a.end=restOfExp(e,n.substring(a.length+1),[expectTypes.inlineIf.types.inlineIf,inlineIfElse]).end,"?"===n.char(a.length)?c++:c--,c||(o=!0);a.start=n.start+1,i.lispTree=createLisp({op:15,a:i.lispTree,b:createLisp({op:16,a:lispifyExpr(e,a),b:lispifyExpr(e,n.substring(r[0].length+a.length+1))})})})),setLispType(["if"],((e,t,n,r,s,i)=>{let o=restOfExp(e,n.substring(r[0].length),[],"(");const a=extractIfElse(e,n.substring(r[1].length));/^\s*\{/.exec(n.substring(r[0].length+o.length+1).toString());const c=r[0].length-r[1].length+o.length+1;let l=a.true.substring(c),p=a.false;o=o.trim(),l=l.trim(),p=p.trim(),"{"===l.char(0)&&(l=l.slice(1,-1)),"{"===p.char(0)&&(p=p.slice(1,-1)),i.lispTree=createLisp({op:13,a:lispifyExpr(e,o),b:createLisp({op:14,a:lispifyBlock(l,e),b:lispifyBlock(p,e)})})})),setLispType(["switch"],((e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[],"(");let a=n.toString().indexOf("{",r[0].length+o.length+1);if(-1===a)throw new SyntaxError("Invalid switch");let c,l=insertSemicolons(e,restOfExp(e,n.substring(a+1),[],"{"));const p=/^\s*(case\s|default)\s*/;let d=[],u=!1;for(;c=p.exec(l.toString());){if("default"===c[1]){if(u)throw new SyntaxError("Only one default switch case allowed");u=!0}let t=restOfExp(e,l.substring(c[0].length),[/^:/]),n=emptyString,r=a=c[0].length+t.length+1,s=/^\s*\{/.exec(l.substring(r).toString()),i=[];if(s)r+=s[0].length,n=restOfExp(e,l.substring(r),[],"{"),r+=n.length+1,i=lispifyBlock(n,e);else{let t=restOfExp(e,l.substring(r),[p]);if(t.trim().length){for(;(n=restOfExp(e,l.substring(r),[semiColon])).length&&(r+=n.length+(";"===l.char(r+n.length)?1:0),!p.test(l.substring(r).toString())););i=lispifyBlock(l.substring(a,n.end-l.start),e)}else i=[],r+=t.length}l=l.substring(r),d.push(createLisp({op:41,a:"default"===c[1]?void 0:lispifyExpr(e,t),b:i}))}i.lispTree=createLisp({op:40,a:lispifyExpr(e,o),b:d})})),setLispType(["dot","prop"],((e,t,n,r,s,i)=>{let o=r[0],a=r[0].length,c="prop";if("dot"===t){r[1]&&(c="?prop");let e=n.substring(r[0].length).toString().match(expectTypes.prop.types.prop);if(!e||!e.length)throw new SyntaxError("Hanging  dot");o=e[0],a=o.length+r[0].length}i.lispTree=lispify(e,n.substring(a),expectTypes[s].next,createLisp({op:typesCreate[c],a:i.lispTree,b:o}))})),setLispType(["spreadArray","spreadObject"],((e,t,n,r,s,i)=>{i.lispTree=createLisp({op:"spreadArray"===t?18:17,a:0,b:lispify(e,n.substring(r[0].length),expectTypes[s].next)})})),setLispType(["return","throw"],((e,t,n,r,s,i)=>{i.lispTree=createLisp({op:"return"===t?8:46,a:0,b:lispifyExpr(e,n.substring(r[0].length))})})),setLispType(["number","boolean","null","und","NaN","Infinity"],((e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,createLisp({op:"number"===t?r[10]?83:7:35,a:0,b:r[10]?r[1]:r[0]}))})),setLispType(["string","literal","regex"],((e,t,n,r,s,i)=>{i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,createLisp({op:"string"===t?2:"literal"===t?84:85,a:0,b:r[1]}))})),setLispType(["initialize"],((e,t,n,r,s,i)=>{const o="var"===r[1]?34:"let"===r[1]?3:4;r[3]?i.lispTree=createLisp({op:o,a:r[2],b:lispify(e,n.substring(r[0].length),expectTypes[s].next)}):i.lispTree=lispify(e,n.substring(r[0].length),expectTypes[s].next,createLisp({op:o,a:r[2],b:0}))})),setLispType(["function","inlineFunction","arrowFunction","arrowFunctionSingle"],((e,t,n,r,s,i)=>{const o="function"!==t&&"inlineFunction"!==t,a=o&&!r[r.length-1],c=o?2:3,l=r[1]?88:0,p=r[c]?r[c].replace(/\s+/g,"").split(/,/g):[];o||p.unshift((r[2]||"").trimStart());let d=!1;p.forEach((e=>{if(d)throw new SyntaxError("Rest parameter must be last formal parameter");e.startsWith("...")&&(d=!0)})),p.unshift(l);const u=restOfExp(e,n.substring(r[0].length),a?[/^[,\)\}\]]/,semiColon]:[/^}/]),f=a?"return "+u:u.toString();i.lispTree=lispify(e,n.substring(r[0].length+f.length+1),expectTypes[s].next,createLisp({op:o?11:"function"===t?37:10,a:p,b:e.eager?lispifyFunction(new CodeString(f),e):f}))}));const iteratorRegex=/^((let|var|const)\s+)?\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s+(in|of)(?![\w\$])/;setLispType(["for","do","while"],((e,t,n,r,s,i)=>{let o,a,c,l=0,p=88,d=[],u=0,f=88,h=88;switch(t){case"while":l=n.toString().indexOf("(")+1;let t=restOfExp(e,n.substring(l),[],"(");a=lispifyReturnExpr(e,t),c=restOfExp(e,n.substring(l+t.length+1)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"for":l=n.toString().indexOf("(")+1;let s,i=[],g=emptyString;for(let t=0;t<3&&(g=restOfExp(e,n.substring(l),[/^[;\)]/]),i.push(g.trim()),l+=g.length+1,")"!==n.char(l-1));t++);if(1===i.length&&(s=iteratorRegex.exec(i[0].toString())))"of"===s[4]?(o=lispifyReturnExpr(e,i[0].substring(s[0].length)),d=[ofStart2,ofStart3],a=ofCondition,h=ofStep,u=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$next.value"),["initialize"])):(o=lispifyReturnExpr(e,i[0].substring(s[0].length)),d=[inStart2,inStart3],h=inStep,a=inCondition,u=lispify(e,new CodeString((s[1]||"let ")+s[3]+" = $$keys[$$keyIndex]"),["initialize"]));else{if(3!==i.length)throw new SyntaxError("Invalid for loop definition");p=lispifyExpr(e,i.shift(),startingExecpted),a=lispifyReturnExpr(e,i.shift()),h=lispifyExpr(e,i.shift())}c=restOfExp(e,n.substring(l)).trim(),"{"===c[0]&&(c=c.slice(1,-1));break;case"do":f=0;const y=!!r[3];c=restOfExp(e,n.substring(r[0].length),y?[/^\}/]:[semiColon]),a=lispifyReturnExpr(e,restOfExp(e,n.substring(n.toString().indexOf("(",r[0].length+c.length)+1),[],"("))}const g=[f,d,o,p,h,a,u];i.lispTree=createLisp({op:38,a:g,b:lispifyBlock(c,e)})})),setLispType(["block"],((e,t,n,r,s,i)=>{i.lispTree=createLisp({op:42,a:lispifyBlock(restOfExp(e,n.substring(1),[],"{"),e),b:0})})),setLispType(["loopAction"],((e,t,n,r,s,i)=>{i.lispTree=createLisp({op:86,a:r[1],b:0})}));const catchReg=/^\s*(catch\s*(\(\s*([a-zA-Z\$_][a-zA-Z\d\$_]*)\s*\))?|finally)\s*\{/;setLispType(["try"],((e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[],"{");let a,c,l=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),p="",d=0;l[1].startsWith("catch")?(l=catchReg.exec(n.substring(r[0].length+o.length+1).toString()),p=l[2],c=restOfExp(e,n.substring(r[0].length+o.length+1+l[0].length),[],"{"),d=r[0].length+o.length+1+l[0].length+c.length+1,(l=catchReg.exec(n.substring(d).toString()))&&l[1].startsWith("finally")&&(a=restOfExp(e,n.substring(d+l[0].length),[],"{"))):a=restOfExp(e,n.substring(r[0].length+o.length+1+l[0].length),[],"{");const u=[p,lispifyBlock(insertSemicolons(e,c||emptyString),e),lispifyBlock(insertSemicolons(e,a||emptyString),e)];i.lispTree=createLisp({op:39,a:lispifyBlock(insertSemicolons(e,o),e),b:u})})),setLispType(["void","await"],((e,t,n,r,s,i)=>{const o=restOfExp(e,n.substring(r[0].length),[/^([^\s\.\?\w\$]|\?[^\.])/]);i.lispTree=lispify(e,n.substring(r[0].length+o.length),expectTypes[s].next,createLisp({op:"void"===t?87:44,a:lispify(e,o),b:0}))})),setLispType(["new"],((e,t,n,r,s,i)=>{let o=r[0].length;const a=restOfExp(e,n.substring(o),[],void 0,"(");o+=a.length+1;const c=[];if("("===n.char(o-1)){const t=restOfExp(e,n.substring(o),[],"(");let r;o+=t.length+1;let s=0;for(;(r=restOfExp(e,t.substring(s),[/^,/])).length;)s+=r.length+1,c.push(r.trim())}i.lispTree=lispify(e,n.substring(o),expectTypes.expEdge.next,createLisp({op:45,a:lispify(e,a,expectTypes.initialize.next),b:c.map((t=>lispify(e,t,expectTypes.initialize.next)))}))}));const ofStart2=lispify(void 0,new CodeString("let $$iterator = $$obj[Symbol.iterator]()"),["initialize"]),ofStart3=lispify(void 0,new CodeString("let $$next = $$iterator.next()"),["initialize"]),ofCondition=lispify(void 0,new CodeString("return !$$next.done"),["initialize"]),ofStep=lispify(void 0,new CodeString("$$next = $$iterator.next()")),inStart2=lispify(void 0,new CodeString("let $$keys = Object.keys($$obj)"),["initialize"]),inStart3=lispify(void 0,new CodeString("let $$keyIndex = 0"),["initialize"]),inStep=lispify(void 0,new CodeString("$$keyIndex++")),inCondition=lispify(void 0,new CodeString("return $$keyIndex < $$keys.length"),["initialize"]);var lastType;function lispify(e,t,n,r,s=!1){if(r=r||[0,0,0],n=n||expectTypes.initialize.next,void 0===t)return r;const i=(t=t.trimStart()).toString();if(!t.length&&!n.includes("expEnd"))throw new SyntaxError("Unexpected end of expression");if(!t.length)return r;let o,a={lispTree:r};for(let r of n)if("expEnd"!==r){for(let n in expectTypes[r].types)if("expEnd"!==n&&(o=expectTypes[r].types[n].exec(i))){lastType=n;try{lispTypes.get(n)(e,n,t,o,r,a)}catch(e){if(s&&e instanceof SyntaxError)throw new ParseError(e.message,i);throw e}break}if(o)break}if(!o&&t.length){if(t.char(0),s)throw new ParseError(`Unexpected token after ${lastType}: ${t.char(0)}`,i);throw new SyntaxError(`Unexpected token after ${lastType}: ${t.char(0)}`)}return a.lispTree}const startingExpectedWithoutSingle=startingExecpted.filter((e=>"expSingle"!==e));function lispifyExpr(e,t,n){if(!t.trimStart().length)return;let r,s=[],i=0;if((n=n||expectTypes.initialize.next).includes("expSingle")&&testMultiple(t.toString(),Object.values(expectTypes.expSingle.types)))return lispify(e,t,["expSingle"],void 0,!0);for(n===startingExecpted&&(n=startingExpectedWithoutSingle);(r=restOfExp(e,t.substring(i),[/^,/])).length;)s.push(r.trimStart()),i+=r.length+1;if(1===s.length)return lispify(e,t,n,void 0,!0);if(n.includes("initialize")){let r=expectTypes.initialize.types.initialize.exec(s[0].toString());if(r)return createLisp({op:42,a:s.map(((t,n)=>lispify(e,n?new CodeString(r[1]+" "+t):t,["initialize"],void 0,!0))),b:0});if(expectTypes.initialize.types.return.exec(s[0].toString()))return lispify(e,t,n,void 0,!0)}const o=s.map(((t,r)=>lispify(e,t,n,void 0,!0)));return createLisp({op:43,a:o,b:0})}function lispifyReturnExpr(e,t){return createLisp({op:8,a:0,b:lispifyExpr(e,t)})}function lispifyBlock(e,t,n=!1){if(!(e=insertSemicolons(t,e)).trim().length)return[];let r,s=[],i=0,o=0,a={},c=!1,l=!1;for(;(r=restOfExp(t,e.substring(i),[semiColon],void 0,void 0,void 0,a)).length&&(l=e.char(i+r.length)&&";"!==e.char(i+r.length),i+=r.length+(l?0:1),/^\s*else(?![\w\$])/.test(e.substring(i).toString())||a.words.includes("do")&&/^\s*while(?![\w\$])/.test(e.substring(i).toString())?c=!0:(c=!1,s.push(e.substring(o,i-(l?0:1))),o=i),a={},!n););return c&&s.push(e.substring(o,i-(l?0:1))),s.map((e=>e.trimStart())).filter((e=>e.length)).map(((e,n)=>lispifyExpr(t,e.trimStart(),startingExecpted)))}function lispifyFunction(e,t,n=!1){if(!e.trim().length)return[];const r=lispifyBlock(e,t,n);let s=[];return hoist(r,s),s.concat(r)}function isLisp(e){return Array.isArray(e)&&"number"==typeof e[0]&&0!==e[0]&&88!==e[0]}function hoist(e,t){if(isLisp(e)){const[n,r,s]=e;if(39===n||13===n||38===n||40===n)hoist(r,t),hoist(s,t);else if(34===n)t.push(createLisp({op:34,a:r,b:0}));else if(37===n&&r[1])return t.push(e),!0}else if(Array.isArray(e)){const n=[];for(let r of e)hoist(r,t)||n.push(r);n.length!==e.length&&(e.length=0,e.push(...n))}return!1}const closingsNoInsertion=/^(\})\s*(catch|finally|else|while|instanceof)(?![\w\$])/,colonsRegex=/^((([\w\$\]\)\"\'\`]|\+\+|\-\-)\s*\r?\n\s*([\w\$\+\-\!~]))|(\}\s*[\w\$\!~\+\-\{\(\"\'\`]))/;function insertSemicolons(e,t){let n=t,r=emptyString,s={};const i=insertedSemicolons.get(t.ref)||new Array(t.ref.str.length);for(;(r=restOfExp(e,n,[],void 0,void 0,[colonsRegex],s)).length;){let e=!1,t=r,o=r.length;if(s.regRes){e=!0;const[,,i,,,a]=s.regRes;if(o="++"===s.regRes[3]||"--"===s.regRes[3]?r.length+1:r.length,t=n.substring(0,o),a){let t=closingsNoInsertion.exec(n.substring(r.length-1).toString());t?e="while"===t[2]&&"do"!==s.lastWord:"function"===s.lastWord&&"}"===s.regRes[5][0]&&"("===s.regRes[5].slice(-1)&&(e=!1)}else i&&("if"!==s.lastWord&&"while"!==s.lastWord&&"for"!==s.lastWord&&"else"!==s.lastWord||(e=!1))}e&&(i[t.end]=!0),n=n.substring(o),s={}}return insertedSemicolons.set(t.ref,i),t}function checkRegex(e){let t=1,n=!1,r=!1,s=!1;for(;t<e.length&&!r&&!s;)r="/"===e[t]&&!n,n="\\"===e[t]&&!n,s="\n"===e[t],t++;let i=e.substring(t);if(s=s||!r||/^\s*\d/.test(i),s)return null;let o=/^[a-z]*/.exec(i);return/^\s+[\w\$]/.test(e.substring(t+o[0].length))?null:{regex:e.substring(1,t-1),flags:o&&o[0]||"",length:t+(o&&o[0].length||0)}}const notDivide=/(typeof|delete|instanceof|return|in|of|throw|new|void|do|if)$/,possibleDivide=/^([\w\$\]\)]|\+\+|\-\-)[\s\/]/;function extractConstants(e,t,n=""){let r,s,i=[],o=!1,a="",c=-1,l=[],p="";const d=[],u=[];let f;for(var h=0;h<t.length;h++)if(p=t[h],a)p===a&&("*"===a&&"/"===t[h+1]?(a="",h++):"\n"===a&&(a=""));else{if(o){o=!1,i.push(p);continue}if(r)if("`"===r&&"$"===p&&"{"===t[h+1]){let n=extractConstants(e,t.substring(h+2),"{");l.push(n.str),i.push("${",l.length-1,"}"),h+=n.length+2}else if(r===p){if("`"===r){const t=createLisp({op:36,a:unraw(i.join("")),b:[]});t.tempJsStrings=l,e.literals.push(t),d.push("`",e.literals.length-1,"`")}else e.strings.push(unraw(i.join(""))),d.push('"',e.strings.length-1,'"');r=null,i=[]}else i.push(p);else{if("'"===p||'"'===p||"`"===p)l=[],r=p;else{if(closings[n]===p&&!u.length)return{str:d.join(""),length:h};closings[p]?(u.push(p),d.push(p)):closings[u[u.length-1]]===p?(u.pop(),d.push(p)):"/"!==p||"*"!==t[h+1]&&"/"!==t[h+1]?"/"===p&&!f&&(s=checkRegex(t.substring(h)))?(e.regexes.push(s),d.push("/",e.regexes.length-1,"/r"),h+=s.length-1):d.push(p):(a="*"===t[h+1]?"*":"\n",c=h)}f&&space.test(p)||(f=possibleDivide.exec(t.substring(h)))&&notDivide.test(t.substring(0,h+f[1].length))&&(f=null)}o=r&&"\\"===p}if(a&&"*"===a)throw new SyntaxError(`Unclosed comment '/*': ${t.substring(c)}`);return{str:d.join(""),length:h}}function parse(e,t=!1,n=!1){if("string"!=typeof e)throw new ParseError(`Cannot parse ${e}`,e);let r=" "+e;const s={strings:[],literals:[],regexes:[],eager:t};r=extractConstants(s,r).str;for(let e of s.literals)e[2]=e.tempJsStrings.map((e=>lispifyExpr(s,new CodeString(e)))),delete e.tempJsStrings;return{tree:lispifyFunction(new CodeString(r),s,n),constants:s}}class ExecReturn{constructor(e,t,n,r=!1,s=!1){this.auditReport=e,this.result=t,this.returned=n,this.breakLoop=r,this.continueLoop=s}}class Prop{constructor(e,t,n=!1,r=!1,s=!1){this.context=e,this.prop=t,this.isConst=n,this.isGlobal=r,this.isVariable=s}get(e){if(void 0===this.context)throw new ReferenceError(`${this.prop} is not defined`);return e.getSubscriptions.forEach((e=>e(this.context,this.prop))),this.context[this.prop]}}const optional={},reservedWords=new Set(["instanceof","typeof","return","try","catch","if","finally","else","in","of","var","let","const","for","delete","false","true","while","do","break","continue","new","function","async","await","switch","case"]);var VarType,e;function keysOnly(e){const t=Object.assign({},e);for(let e in t)t[e]=!0;return t}e=VarType||(VarType={}),e.let="let",e.const="const",e.var="var";class Scope{constructor(e,t={},n){this.const={},this.let={},this.var={};const r=void 0!==n||null===e;this.parent=e,this.allVars=t,this.let=r?this.let:keysOnly(t),this.var=r?keysOnly(t):this.var,this.globals=null===e?keysOnly(t):{},this.functionThis=n}get(e,t=!1){if("this"===e&&void 0!==this.functionThis)return new Prop({this:this.functionThis},e,!0,!1,!0);if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if(null===this.parent||!t||void 0!==this.functionThis){if(this.globals.hasOwnProperty(e))return new Prop(this.functionThis,e,!1,!0,!0);if(e in this.allVars&&(!(e in{})||this.allVars.hasOwnProperty(e)))return new Prop(this.allVars,e,this.const.hasOwnProperty(e),this.globals.hasOwnProperty(e),!0);if(null===this.parent)return new Prop(void 0,e)}return this.parent.get(e,t)}set(e,t){if("this"===e)throw new SyntaxError('"this" cannot be assigned');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");let n=this.get(e);if(void 0===n.context)throw new ReferenceError(`Variable '${e}' was not declared.`);if(n.isConst)throw new TypeError(`Cannot assign to const variable '${e}'`);if(n.isGlobal)throw new SandboxError(`Cannot override global variable '${e}'`);return n.context[n.prop]=t,n}declare(e,t=null,n=void 0,r=!1){if("this"===e)throw new SyntaxError('"this" cannot be declared');if(reservedWords.has(e))throw new SyntaxError("Unexepected token '"+e+"'");if("var"===t&&void 0===this.functionThis&&null!==this.parent)return this.parent.declare(e,t,n,r);if((!this[t].hasOwnProperty(e)||"const"===t||this.globals.hasOwnProperty(e))&&e in this.allVars)throw new SandboxError(`Identifier '${e}' has already been declared`);return r&&(this.globals[e]=!0),this[t][e]=!0,this.allVars[e]=n,new Prop(this.allVars,e,this.const.hasOwnProperty(e),r)}}class FunctionScope{}class LocalScope{}class SandboxError extends Error{}let currentTicks;function sandboxFunction(e,t){return function(...n){let r=parse(n.pop()||"");return createFunction(n,r.tree,t||currentTicks,{...e,constants:r.constants,tree:r.tree},void 0,"anonymous")}}function generateArgs(e,t){const n={};return e.forEach(((e,r)=>{e.startsWith("...")?n[e.substring(3)]=t.slice(r):n[e]=t[r]})),n}const sandboxedFunctions=new WeakSet;function createFunction(e,t,n,r,s,i){if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");let o;return o=void 0===i?(...i)=>{const o=generateArgs(e,i);return executeTree(n,r,t,void 0===s?[]:[new Scope(s,o)]).result}:function(...i){const o=generateArgs(e,i);return executeTree(n,r,t,void 0===s?[]:[new Scope(s,o,this)]).result},r.registerSandboxFunction(o),sandboxedFunctions.add(o),o}function createFunctionAsync(e,t,n,r,s,i){if(r.ctx.options.forbidFunctionCreation)throw new SandboxError("Function creation is forbidden");if(!r.ctx.prototypeWhitelist?.has(Promise.prototype))throw new SandboxError("Async/await not permitted");let o;return o=void 0===i?async(...i)=>{const o=generateArgs(e,i);return(await executeTreeAsync(n,r,t,void 0===s?[]:[new Scope(s,o)])).result}:async function(...i){const o=generateArgs(e,i);return(await executeTreeAsync(n,r,t,void 0===s?[]:[new Scope(s,o,this)])).result},r.registerSandboxFunction(o),sandboxedFunctions.add(o),o}function sandboxedEval(e){return function(t){return e(t)()}}function sandboxedSetTimeout(e){return function(t,...n){return"string"!=typeof t?setTimeout(t,...n):setTimeout(e(t),...n)}}function sandboxedSetInterval(e){return function(t,...n){return"string"!=typeof t?setInterval(t,...n):setInterval(e(t),...n)}}function assignCheck(e,t,n="assign"){if(void 0===e.context)throw new ReferenceError(`Cannot ${n} value to undefined.`);if("object"!=typeof e.context&&"function"!=typeof e.context)throw new SyntaxError(`Cannot ${n} value to a primitive.`);if(e.isConst)throw new TypeError(`Cannot set value to const variable '${e.prop}'`);if(e.isGlobal)throw new SandboxError(`Cannot ${n} property '${e.prop}' of a global object`);if("function"==typeof e.context[e.prop]&&!e.context.hasOwnProperty(e.prop))throw new SandboxError(`Override prototype property '${e.prop}' not allowed`);"delete"===n?e.context.hasOwnProperty(e.prop)&&(t.changeSubscriptions.get(e.context)?.forEach((t=>t({type:"delete",prop:e.prop}))),t.changeSubscriptionsGlobal.get(e.context)?.forEach((t=>t({type:"delete",prop:e.prop})))):e.context.hasOwnProperty(e.prop)?(t.setSubscriptions.get(e.context)?.get(e.prop)?.forEach((e=>e({type:"replace"}))),t.setSubscriptionsGlobal.get(e.context)?.get(e.prop)?.forEach((e=>e({type:"replace"})))):(t.changeSubscriptions.get(e.context)?.forEach((t=>t({type:"create",prop:e.prop}))),t.changeSubscriptionsGlobal.get(e.context)?.forEach((t=>t({type:"create",prop:e.prop}))))}const arrayChange=new Set([[].push,[].pop,[].shift,[].unshift,[].splice,[].reverse,[].sort,[].copyWithin]);class KeyVal{constructor(e,t){this.key=e,this.val=t}}class SpreadObject{constructor(e){this.item=e}}class SpreadArray{constructor(e){this.item=e}}class If{constructor(e,t){this.t=e,this.f=t}}const literalRegex=/(\$\$)*(\$)?\${(\d+)}/g,ops=new Map;function addOps(e,t){ops.set(e,t)}function valueOrProp(e,t){return e instanceof Prop?e.get(t):e!==optional?e:void 0}function execMany(e,t,n,r,s,i,o){t===execSync?_execManySync(e,n,r,s,i,o):_execManyAsync(e,n,r,s,i,o).catch(r)}function _execManySync(e,t,n,r,s,i){let o=[];for(let a=0;a<t.length;a++){let c;try{c=syncDone((n=>execSync(e,t[a],r,s,n,i))).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(s.ctx.auditReport,c,!0));o.push(c)}n(void 0,o)}async function _execManyAsync(e,t,n,r,s,i){let o=[];for(let a=0;a<t.length;a++){let c;try{let n;c=!0===(n=asyncDone((n=>execAsync(e,t[a],r,s,n,i)))).isInstant?n.instant:(await n.p).result}catch(e){return void n(e)}if(c instanceof ExecReturn&&(c.returned||c.breakLoop||c.continueLoop))return void n(void 0,c);if(isLisp(t[a])&&8===t[a][0])return void n(void 0,new ExecReturn(s.ctx.auditReport,c,!0));o.push(c)}n(void 0,o)}function asyncDone(e){let t,n=!1;const r=new Promise(((r,s)=>{e(((e,i)=>{e?s(e):(n=!0,t=i,r({result:i}))}))}));return{isInstant:n,instant:t,p:r}}function syncDone(e){let t,n;if(e(((e,r)=>{n=e,t=r})),n)throw n;return{result:t}}async function execAsync(e,t,n,r,s,i){let o=s;const a=new Promise((e=>{o=(t,n)=>{s(t,n),e()}}));if(_execNoneRecurse(e,t,n,r,o,!0,i));else if(isLisp(t)){let s,a=t[0];try{let o;s=!0===(o=asyncDone((s=>execAsync(e,t[1],n,r,s,i)))).isInstant?o.instant:(await o.p).result}catch(e){return void o(e)}let c,l=s;try{l=s instanceof Prop?s.get(r):s}catch(e){return void o(e)}if(20===a||21===a){if(null==l)return void o(void 0,optional);a=20===a?1:5}if(l===optional){if(1===a||5===a)return void o(void 0,l);l=void 0}try{let s;c=!0===(s=asyncDone((s=>execAsync(e,t[2],n,r,s,i)))).isInstant?s.instant:(await s.p).result}catch(e){return void o(e)}let p=c;try{p=c instanceof Prop?c.get(r):c}catch(e){return void o(e)}if(p===optional&&(p=void 0),ops.has(a))try{ops.get(a)(execAsync,o,e,l,p,s,r,n,c,i)}catch(e){o(e)}else o(new SyntaxError("Unknown operator: "+a))}await a}function execSync(e,t,n,r,s,i){if(_execNoneRecurse(e,t,n,r,s,!1,i));else if(isLisp(t)){let o,a=t[0];try{o=syncDone((s=>execSync(e,t[1],n,r,s,i))).result}catch(e){return void s(e)}let c,l=o;try{l=o instanceof Prop?o.get(r):o}catch(e){return void s(e)}if(20===a||21===a){if(null==l)return void s(void 0,optional);a=20===a?1:5}if(l===optional){if(1===a||5===a)return void s(void 0,l);l=void 0}try{c=syncDone((s=>execSync(e,t[2],n,r,s,i))).result}catch(e){return void s(e)}let p=c;try{p=c instanceof Prop?c.get(r):c}catch(e){return void s(e)}if(p===optional&&(p=void 0),ops.has(a))try{ops.get(a)(execSync,s,e,l,p,o,r,n,c,i)}catch(e){s(e)}else s(new SyntaxError("Unknown operator: "+a))}}addOps(1,((e,t,n,r,s,i,o,a)=>{if(null===r)throw new TypeError(`Cannot get property ${s} of null`);const c=typeof r;if("undefined"===c&&void 0===i){let e=a.get(s);if(e.context===o.ctx.sandboxGlobal){o.ctx.options.audit&&o.ctx.auditReport.globalsAccess.add(s);const e=o.ctx.globalsWhitelist.has(o.ctx.sandboxGlobal[s])?o.evals.get(o.ctx.sandboxGlobal[s]):void 0;if(e)return void t(void 0,e)}return e.context&&e.context[s]===globalThis?void t(void 0,o.ctx.globalScope.get("this")):void t(void 0,e)}if(void 0===r)throw new SandboxError("Cannot get property '"+s+"' of undefined");if("object"!==c)"number"===c?r=new Number(r):"string"===c?r=new String(r):"boolean"===c&&(r=new Boolean(r));else if(void 0===r.hasOwnProperty)return void t(void 0,new Prop(void 0,s));const l="function"===c;let p=l||!(r.hasOwnProperty(s)||"number"==typeof s);if(o.ctx.options.audit&&p&&"string"==typeof s){let e=Object.getPrototypeOf(r);do{e.hasOwnProperty(s)&&(o.ctx.auditReport.prototypeAccess[e.constructor.name]||(o.ctx.auditReport.prototypeAccess[e.constructor.name]=new Set),o.ctx.auditReport.prototypeAccess[e.constructor.name].add(s))}while(e=Object.getPrototypeOf(e))}if(p)if(l){if(!["name","length","constructor"].includes(s)&&r.hasOwnProperty(s)){const e=o.ctx.prototypeWhitelist.get(r.prototype),n=o.ctx.options.prototypeReplacements.get(r);if(n)return void t(void 0,new Prop(n(r,!0),s));if(!e||e.size&&!e.has(s))throw new SandboxError(`Static method or property access not permitted: ${r.name}.${s}`)}}else if("constructor"!==s){let e=r;for(;e=Object.getPrototypeOf(e);)if(e.hasOwnProperty(s)){const n=o.ctx.prototypeWhitelist.get(e),i=o.ctx.options.prototypeReplacements.get(e.constuctor);if(i)return void t(void 0,new Prop(i(r,!1),s));if(n&&(!n.size||n.has(s)))break;throw new SandboxError(`Method or property access not permitted: ${e.constructor.name}.${s}`)}}if(o.evals.has(r[s]))return void t(void 0,o.evals.get(r[s]));if(r[s]===globalThis)return void t(void 0,o.ctx.globalScope.get("this"));let d=i.isGlobal||l&&!sandboxedFunctions.has(r)||o.ctx.globalsWhitelist.has(r);t(void 0,new Prop(r,s,!1,d))})),addOps(5,((e,t,n,r,s,i,o,a)=>{if(o.ctx.options.forbidFunctionCalls)throw new SandboxError("Function invocations are not allowed");if("function"!=typeof r)throw new TypeError(`${"symbol"==typeof i.prop?"Symbol":i.prop} is not a function`);const c=s.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat().map((e=>valueOrProp(e,o)));if("function"!=typeof i){if(i.context[i.prop]===JSON.stringify&&o.getSubscriptions.size){const e=new Set,t=n=>{if(n&&"object"==typeof n&&!e.has(n)){e.add(n);for(let e in n)o.getSubscriptions.forEach((t=>t(n,e))),t(n[e])}};t(c[0])}if(i.context instanceof Array&&arrayChange.has(i.context[i.prop])&&(o.changeSubscriptions.get(i.context)||o.changeSubscriptionsGlobal.get(i.context))){let e,t=!1;if("push"===i.prop)e={type:"push",added:c},t=!!c.length;else if("pop"===i.prop)e={type:"pop",removed:i.context.slice(-1)},t=!!e.removed.length;else if("shift"===i.prop)e={type:"shift",removed:i.context.slice(0,1)},t=!!e.removed.length;else if("unshift"===i.prop)e={type:"unshift",added:c},t=!!c.length;else if("splice"===i.prop)e={type:"splice",startIndex:c[0],deleteCount:void 0===c[1]?i.context.length:c[1],added:c.slice(2),removed:i.context.slice(c[0],void 0===c[1]?void 0:c[0]+c[1])},t=!!e.added.length||!!e.removed.length;else if("reverse"===i.prop||"sort"===i.prop)e={type:i.prop},t=!!i.context.length;else if("copyWithin"===i.prop){let n=void 0===c[2]?i.context.length-c[1]:Math.min(i.context.length,c[2]-c[1]);e={type:"copyWithin",startIndex:c[0],endIndex:c[0]+n,added:i.context.slice(c[1],c[1]+n),removed:i.context.slice(c[0],c[0]+n)},t=!!e.added.length||!!e.removed.length}t&&(o.changeSubscriptions.get(i.context)?.forEach((t=>t(e))),o.changeSubscriptionsGlobal.get(i.context)?.forEach((t=>t(e))))}i.get(o),t(void 0,i.context[i.prop](...c))}else t(void 0,i(...c))})),addOps(22,((e,t,n,r,s,i,o,a)=>{let c={};for(let e of s)e.key instanceof SpreadObject?c={...c,...e.key.item}:c[e.key]=e.val;t(void 0,c)})),addOps(6,((e,t,n,r,s)=>t(void 0,new KeyVal(r,s)))),addOps(12,((e,t,n,r,s,i,o,a)=>{t(void 0,s.map((e=>e instanceof SpreadArray?[...e.item]:[e])).flat().map((e=>valueOrProp(e,o))))})),addOps(23,((e,t,n,r,s)=>t(void 0,s))),addOps(35,((e,t,n,r,s)=>{switch(s){case"true":return t(void 0,!0);case"false":return t(void 0,!1);case"null":return t(void 0,null);case"undefined":return t(void 0,void 0);case"NaN":return t(void 0,NaN);case"Infinity":return t(void 0,1/0)}t(new Error("Unknown symbol: "+s))})),addOps(7,((e,t,n,r,s)=>t(void 0,Number(s)))),addOps(83,((e,t,n,r,s)=>t(void 0,BigInt(s)))),addOps(2,((e,t,n,r,s,i,o)=>t(void 0,o.constants.strings[parseInt(s)]))),addOps(85,((e,t,n,r,s,i,o)=>{const a=o.constants.regexes[parseInt(s)];if(!o.ctx.globalsWhitelist.has(RegExp))throw new SandboxError("Regex not permitted");t(void 0,new RegExp(a.regex,a.flags))})),addOps(84,((e,t,n,r,s,i,o,a)=>{let c=o.constants.literals[parseInt(s)];const[,l,p]=c;let d,u=[],f=[];for(;d=literalRegex.exec(l);)d[2]||(u.push(p[parseInt(d[3],10)]),f.push(d[3]));e(n,u,a,o,((e,n)=>{const r={};if(e)t(e);else{for(let e in f){const t=f[e];r[t]=n[e]}t(void 0,l.replace(/(\\\\)*(\\)?\${(\d+)}/g,((e,t,n,s)=>n?e:(t||"")+`${valueOrProp(r[s],o)}`)))}}))})),addOps(18,((e,t,n,r,s,i,o,a)=>{t(void 0,new SpreadArray(s))})),addOps(17,((e,t,n,r,s,i,o,a)=>{t(void 0,new SpreadObject(s))})),addOps(24,((e,t,n,r,s)=>t(void 0,!s))),addOps(64,((e,t,n,r,s)=>t(void 0,~s))),addOps(25,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,++i.context[i.prop])})),addOps(26,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]++)})),addOps(27,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,--i.context[i.prop])})),addOps(28,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]--)})),addOps(9,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]=s)})),addOps(66,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]+=s)})),addOps(65,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]-=s)})),addOps(67,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]/=s)})),addOps(69,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]*=s)})),addOps(68,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]**=s)})),addOps(70,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]%=s)})),addOps(71,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]^=s)})),addOps(72,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]&=s)})),addOps(73,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]|=s)})),addOps(76,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]<<=s)})),addOps(75,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]>>=s)})),addOps(74,((e,t,n,r,s,i,o)=>{assignCheck(i,o),t(void 0,i.context[i.prop]>>=s)})),addOps(57,((e,t,n,r,s)=>t(void 0,r>s))),addOps(56,((e,t,n,r,s)=>t(void 0,r<s))),addOps(55,((e,t,n,r,s)=>t(void 0,r>=s))),addOps(54,((e,t,n,r,s)=>t(void 0,r<=s))),addOps(52,((e,t,n,r,s)=>t(void 0,r==s))),addOps(32,((e,t,n,r,s)=>t(void 0,r===s))),addOps(53,((e,t,n,r,s)=>t(void 0,r!=s))),addOps(31,((e,t,n,r,s)=>t(void 0,r!==s))),addOps(29,((e,t,n,r,s)=>t(void 0,r&&s))),addOps(30,((e,t,n,r,s)=>t(void 0,r||s))),addOps(77,((e,t,n,r,s)=>t(void 0,r&s))),addOps(78,((e,t,n,r,s)=>t(void 0,r|s))),addOps(33,((e,t,n,r,s)=>t(void 0,r+s))),addOps(47,((e,t,n,r,s)=>t(void 0,r-s))),addOps(59,((e,t,n,r,s)=>t(void 0,+s))),addOps(58,((e,t,n,r,s)=>t(void 0,-s))),addOps(48,((e,t,n,r,s)=>t(void 0,r/s))),addOps(79,((e,t,n,r,s)=>t(void 0,r^s))),addOps(50,((e,t,n,r,s)=>t(void 0,r*s))),addOps(51,((e,t,n,r,s)=>t(void 0,r%s))),addOps(80,((e,t,n,r,s)=>t(void 0,r<<s))),addOps(81,((e,t,n,r,s)=>t(void 0,r>>s))),addOps(82,((e,t,n,r,s)=>t(void 0,r>>>s))),addOps(60,((e,t,n,r,s,i,o,a)=>{e(n,s,a,o,((e,n)=>{t(void 0,typeof valueOrProp(n,o))}))})),addOps(62,((e,t,n,r,s)=>t(void 0,r instanceof s))),addOps(63,((e,t,n,r,s)=>t(void 0,r in s))),addOps(61,((e,t,n,r,s,i,o,a,c)=>{void 0!==c.context?(assignCheck(c,o,"delete"),c.isVariable?t(void 0,!1):t(void 0,delete c.context[c.prop])):t(void 0,!0)})),addOps(8,((e,t,n,r,s,i,o)=>t(void 0,s))),addOps(34,((e,t,n,r,s,i,o,a,c)=>{t(void 0,a.declare(r,VarType.var,s))})),addOps(3,((e,t,n,r,s,i,o,a,c)=>{t(void 0,a.declare(r,VarType.let,s,c&&c.isGlobal))})),addOps(4,((e,t,n,r,s,i,o,a,c)=>{t(void 0,a.declare(r,VarType.const,s))})),addOps(11,((e,t,n,r,s,i,o,a)=>{r=[...r],("string"==typeof i[2]||i[2]instanceof CodeString)&&(i[2]=s=lispifyFunction(new CodeString(i[2]),o.constants)),r.shift()?t(void 0,createFunctionAsync(r,s,n,o,a)):t(void 0,createFunction(r,s,n,o,a))})),addOps(37,((e,t,n,r,s,i,o,a)=>{("string"==typeof i[2]||i[2]instanceof CodeString)&&(i[2]=s=lispifyFunction(new CodeString(i[2]),o.constants));let c,l=r.shift(),p=r.shift();c=88===l?createFunctionAsync(r,s,n,o,a,p):createFunction(r,s,n,o,a,p),p&&a.declare(p,VarType.var,c),t(void 0,c)})),addOps(10,((e,t,n,r,s,i,o,a)=>{("string"==typeof i[2]||i[2]instanceof CodeString)&&(i[2]=s=lispifyFunction(new CodeString(i[2]),o.constants));let c,l=r.shift(),p=r.shift();p&&(a=new Scope(a,{})),c=88===l?createFunctionAsync(r,s,n,o,a,p):createFunction(r,s,n,o,a,p),p&&a.declare(p,VarType.let,c),t(void 0,c)})),addOps(38,((e,t,n,r,s,i,o,a)=>{const[c,l,p,d,u,f,h]=r;let g=!0;const y=new Scope(a,{});let x={$$obj:void 0};const b=new Scope(y,x);if(e===execAsync)(async()=>{let r;for(r=asyncDone((t=>e(n,d,y,o,t))),x.$$obj=!0===(r=asyncDone((t=>e(n,p,y,o,t)))).isInstant?r.instant:(await r.p).result,r=asyncDone((t=>e(n,l,b,o,t))),c&&(g=!0===(r=asyncDone((t=>e(n,f,b,o,t)))).isInstant?r.instant:(await r.p).result);g;){let i={};r=asyncDone((t=>e(n,h,new Scope(b,i),o,t))),!0===r.isInstant?r.instant:(await r.p).result;let a=await executeTreeAsync(n,o,s,[new Scope(y,i)],"loop");if(a instanceof ExecReturn&&a.returned)return void t(void 0,a);if(a instanceof ExecReturn&&a.breakLoop)break;r=asyncDone((t=>e(n,u,b,o,t))),g=!0===(r=asyncDone((t=>e(n,f,b,o,t)))).isInstant?r.instant:(await r.p).result}t()})().catch(t);else{for(syncDone((t=>e(n,d,y,o,t))),x.$$obj=syncDone((t=>e(n,p,y,o,t))).result,syncDone((t=>e(n,l,b,o,t))),c&&(g=syncDone((t=>e(n,f,b,o,t))).result);g;){let r={};syncDone((t=>e(n,h,new Scope(b,r),o,t)));let i=executeTree(n,o,s,[new Scope(y,r)],"loop");if(i instanceof ExecReturn&&i.returned)return void t(void 0,i);if(i instanceof ExecReturn&&i.breakLoop)break;syncDone((t=>e(n,u,b,o,t))),g=syncDone((t=>e(n,f,b,o,t))).result}t()}})),addOps(86,((e,t,n,r,s,i,o,a,c,l)=>{if("switch"===l&&"continue"===r||!l)throw new SandboxError("Illegal "+r+" statement");t(void 0,new ExecReturn(o.ctx.auditReport,void 0,!1,"break"===r,"continue"===r))})),addOps(13,((e,t,n,r,s,i,o,a,c,l)=>{e(n,valueOrProp(r,o)?s.t:s.f,a,o,t)})),addOps(15,((e,t,n,r,s,i,o,a)=>{e(n,valueOrProp(r,o)?s.t:s.f,a,o,t)})),addOps(16,((e,t,n,r,s)=>t(void 0,new If(r,s)))),addOps(14,((e,t,n,r,s)=>t(void 0,new If(r,s)))),addOps(40,((e,t,n,r,s,i,o,a)=>{e(n,r,a,o,((r,i)=>{if(r)t(r);else if(i=valueOrProp(i,o),e===execSync){let r,c=!1;for(let l of s)if(c||(c=!l[1]||i===valueOrProp(syncDone((t=>e(n,l[1],a,o,t))).result,o))){if(!l[2])continue;if(r=executeTree(n,o,l[2],[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l[1])break}t()}else(async()=>{let r,c=!1;for(let l of s){let s;if(c||(c=!l[1]||i===valueOrProp(!0===(s=asyncDone((t=>e(n,l[1],a,o,t)))).isInstant?s.instant:(await s.p).result,o))){if(!l[2])continue;if(r=await executeTreeAsync(n,o,l[2],[a],"switch"),r.breakLoop)break;if(r.returned)return void t(void 0,r);if(!l[1])break}}t()})().catch(t)}))})),addOps(39,((e,t,n,r,s,i,o,a,c,l)=>{const[p,d,u]=s;executeTreeWithDone(e,((r,s)=>{executeTreeWithDone(e,(i=>{i?t(i):r?executeTreeWithDone(e,t,n,o,d,[new Scope(a)],l):t(void 0,s)}),n,o,u,[new Scope(a,{})])}),n,o,r,[new Scope(a)],l)})),addOps(87,((e,t,n,r)=>{t()})),addOps(45,((e,t,n,r,s,i,o)=>{if(!o.ctx.globalsWhitelist.has(r)&&!sandboxedFunctions.has(r))throw new SandboxError(`Object construction not allowed: ${r.constructor.name}`);t(void 0,new r(...s))})),addOps(46,((e,t,n,r,s)=>{t(s)})),addOps(43,((e,t,n,r)=>t(void 0,r.pop()))),addOps(0,((e,t,n,r)=>t()));const unexecTypes=new Set([11,37,10,38,39,40,14,16,60]);function _execNoneRecurse(e,t,n,r,s,i,o){const a=i?execAsync:execSync;if(!(r.ctx.options.executionQuota<=e.ticks)||"function"==typeof r.ctx.options.onExecutionQuotaReached&&r.ctx.options.onExecutionQuotaReached(e,n,r,t)){if(e.ticks++,currentTicks=e,t instanceof Prop)try{s(void 0,t.get(r))}catch(e){s(e)}else if(t===optional)s();else if(Array.isArray(t)&&!isLisp(t))0===t[0]?s():execMany(e,a,t,s,n,r,o);else if(isLisp(t))if(42===t[0])execMany(e,a,t[1],s,n,r,o);else if(44===t[0])i?r.ctx.prototypeWhitelist?.has(Promise.prototype)?execAsync(e,t[1],n,r,(async(e,t)=>{if(e)s(e);else try{s(void 0,await valueOrProp(t,r))}catch(e){s(e)}}),o).catch(s):s(new SandboxError("Async/await is not permitted")):s(new SandboxError("Illegal use of 'await', must be inside async function"));else{if(!unexecTypes.has(t[0]))return!1;try{ops.get(t[0])(a,s,e,t[1],t[2],t,r,n,void 0,o)}catch(e){s(e)}}else s(void 0,t);return!0}s(new SandboxError("Execution quota exceeded"))}function executeTree(e,t,n,r=[],s){return syncDone((i=>executeTreeWithDone(execSync,i,e,t,n,r,s))).result}async function executeTreeAsync(e,t,n,r=[],s){let i;return!0===(i=asyncDone((i=>executeTreeWithDone(execAsync,i,e,t,n,r,s)))).isInstant?i.instant:(await i.p).result}function executeTreeWithDone(e,t,n,r,s,i=[],o){if(!s)return void t();if(!(s instanceof Array))throw new SyntaxError("Bad execution tree");let a,c=r.ctx.globalScope;for(;a=i.shift();)"object"==typeof a&&(c=a instanceof Scope?a:new Scope(c,a,a instanceof LocalScope?void 0:null));r.ctx.options.audit&&!r.ctx.auditReport&&(r.ctx.auditReport={globalsAccess:new Set,prototypeAccess:{}}),e===execSync?_executeWithDoneSync(t,n,r,s,c,o):_executeWithDoneAsync(t,n,r,s,c,o).catch(t)}function _executeWithDoneSync(e,t,n,r,s,i){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{execSync(t,l,s,n,((e,t)=>{c=e,a=t}),i)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(l)&&8===l[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}async function _executeWithDoneAsync(e,t,n,r,s,i){if(!(r instanceof Array))throw new SyntaxError("Bad execution tree");let o=0;for(o=0;o<r.length;o++){let a,c;const l=r[o];try{await execAsync(t,l,s,n,((e,t)=>{c=e,a=t}),i)}catch(e){c=e}if(c)return void e(c);if(a instanceof ExecReturn)return void e(void 0,a);if(isLisp(l)&&8===l[0])return void e(void 0,new ExecReturn(n.ctx.auditReport,a,!0))}e(void 0,new ExecReturn(n.ctx.auditReport,void 0,!1))}class SandboxGlobal{constructor(e){if(e===globalThis)return globalThis;for(let t in e)this[t]=e[t]}}class ExecContext{constructor(e,t,n,r,s,i,o,a,c,l){this.ctx=e,this.constants=t,this.tree=n,this.getSubscriptions=r,this.setSubscriptions=s,this.changeSubscriptions=i,this.setSubscriptionsGlobal=o,this.changeSubscriptionsGlobal=a,this.evals=c,this.registerSandboxFunction=l}}function subscribeSet(e,t,n,r){const s=r.setSubscriptions.get(e)||new Map;r.setSubscriptions.set(e,s);const i=s.get(t)||new Set;let o;return s.set(t,i),i.add(n),e&&e[t]&&"object"==typeof e[t]&&(o=r.changeSubscriptions.get(e[t])||new Set,o.add(n),r.changeSubscriptions.set(e[t],o)),{unsubscribe:()=>{i.delete(n),o?.delete(n)}}}class Sandbox{constructor(e){this.setSubscriptions=new WeakMap,this.changeSubscriptions=new WeakMap,this.sandboxFunctions=new WeakMap,e=Object.assign({audit:!1,forbidFunctionCalls:!1,forbidFunctionCreation:!1,globals:Sandbox.SAFE_GLOBALS,prototypeWhitelist:Sandbox.SAFE_PROTOTYPES,prototypeReplacements:new Map},e||{});const t=new SandboxGlobal(e.globals);this.context={sandbox:this,globalsWhitelist:new Set(Object.values(e.globals)),prototypeWhitelist:new Map([...e.prototypeWhitelist].map((e=>[e[0].prototype,e[1]]))),options:e,globalScope:new Scope(null,e.globals,t),sandboxGlobal:t},this.context.prototypeWhitelist.set(Object.getPrototypeOf([][Symbol.iterator]()),new Set)}static get SAFE_GLOBALS(){return{Function,console:{debug:console.debug,error:console.error,info:console.info,log:console.log,table:console.table,warn:console.warn},isFinite,isNaN,parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,escape,unescape,Boolean,Number,BigInt,String,Object,Array,Symbol,Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Intl,JSON,Math,Date,RegExp}}static get SAFE_PROTOTYPES(){let e=[SandboxGlobal,Function,Boolean,Number,BigInt,String,Date,Error,Array,Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array,Map,Set,WeakMap,WeakSet,Promise,Symbol,Date,RegExp],t=new Map;return e.forEach((e=>{t.set(e,new Set)})),t.set(Object,new Set(["entries","fromEntries","getOwnPropertyNames","is","keys","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf","values"])),t}subscribeGet(e,t){return t.getSubscriptions.add(e),{unsubscribe:()=>t.getSubscriptions.delete(e)}}subscribeSet(e,t,n,r){return subscribeSet(e,t,n,r)}subscribeSetGlobal(e,t,n){return subscribeSet(e,t,n,this)}static audit(e,t=[]){const n={};for(let e of Object.getOwnPropertyNames(globalThis))n[e]=globalThis[e];const r=new Sandbox({globals:n,audit:!0});return r.executeTree(r.createContext(r.context,parse(e)),t)}static parse(e){return parse(e)}createContext(context,executionTree){const evals=new Map,execContext=new ExecContext(context,executionTree.constants,executionTree.tree,new Set,new WeakMap,new WeakMap,this.setSubscriptions,this.changeSubscriptions,evals,(e=>this.sandboxFunctions.set(e,execContext))),func=sandboxFunction(execContext);return evals.set(Function,func),evals.set(eval,sandboxedEval(func)),evals.set(setTimeout,sandboxedSetTimeout(func)),evals.set(setInterval,sandboxedSetInterval(func)),execContext}getContext(e){return this.sandboxFunctions.get(e)}executeTree(e,t=[]){return executeTree({ticks:BigInt(0)},e,e.tree,t)}executeTreeAsync(e,t=[]){return executeTreeAsync({ticks:BigInt(0)},e,e.tree,t)}compile(e,t=!1){const n=parse(e,t);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileAsync(e,t=!1){const n=parse(e,t);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then((e=>e.result))}}}compileExpression(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTree(t,[...e]).result}}}compileExpressionAsync(e,t=!1){const n=parse(e,t,!0);return(...e)=>{const t=this.createContext(this.context,n);return{context:t,run:()=>this.executeTreeAsync(t,[...e]).then((e=>e.result))}}}}function _classPrivateMethodInitSpec(e,t){_checkPrivateRedeclaration(e,t),t.add(e)}function _checkPrivateRedeclaration(e,t){if(t.has(e))throw new TypeError("Cannot initialize the same private elements twice on an object")}function _assertClassBrand(e,t,n){if("function"==typeof e?e===t:e.has(t))return arguments.length<3?t:n;throw new TypeError("Private element is not present on this object")}const{eventSource,event_types,executeSlashCommands}=SillyTavern.getContext(),events=[event_types.CHARACTER_MESSAGE_RENDERED,event_types.USER_MESSAGE_RENDERED,event_types.CHAT_CHANGED,event_types.MESSAGE_SWIPED];events.push("MESSAGE_UPDATED"in event_types?event_types.MESSAGE_UPDATED:event_types.MESSAGE_EDITED);const clearedSymbol=Symbol("cancel"),supportedLanguages=["language-javascript","language-stscript"];for(const e of events)eventSource.on(e,addExecuteButtonToCodeBlocks);function addExecuteButtonToCodeBlocks(){const e=Array.from(document.querySelectorAll("#chat pre code"));for(const t of e)if(!t.classList.contains("code-runner")&&supportedLanguages.some((e=>t.classList.contains(e)))){const e=t.className.match(/language-(\w+)/)[1];addExecuteButton(t,e),t.classList.add("code-runner")}}function addExecuteButton(e,t){const n=document.createElement("i");n.title="Run code",n.classList.add("code-runner-button","fa-solid","fa-play"),n.addEventListener("click",(()=>{"javascript"===t&&runJavaScriptCode(e),"stscript"===t&&runSTScriptCode(e)})),e.appendChild(n)}function getOutputElement(e){let t=e.parentElement.querySelector(".code-output");t||(t=document.createElement("blockquote"),t.classList.add("code-output"),e.parentElement.appendChild(t)),t.innerHTML="";const n=document.createElement("i");n.classList.add("code-output-hourglass","fa-solid","fa-hourglass","fa-2x"),n.style.display="none";const r=document.createElement("i");r.classList.add("code-output-clear","fa-solid","fa-xmark","fa-fw"),r.title="Clear output",r.onclick=()=>{t.remove()},t.appendChild(r),t.appendChild(n);const s=new Promise((e=>{r.addEventListener("click",(()=>e(clearedSymbol)),{once:!0})}));return{outputElement:t,clearClicked:s}}function showLoader(e){const t=e.querySelector(".code-output-hourglass");t&&(t.style.display="block")}function hideLoader(e){const t=e.querySelector(".code-output-hourglass");t&&(t.style.display="none")}var _CustomConsole_brand=new WeakSet;class CustomConsole{constructor(e){_classPrivateMethodInitSpec(this,_CustomConsole_brand),_assertClassBrand(_CustomConsole_brand,this,_setupShims).call(this),this.outputElement=e}info(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}log(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}error(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}warn(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}debug(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}table(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}trace(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}alert(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];_assertClassBrand(_CustomConsole_brand,this,_addToOutput).call(this,t)}addResult(e,t){const n=document.createElement("div"),r=document.createElement("small"),s=(t/1e3).toFixed(2);r.textContent="Finished in ".concat(s," sec. Result: ").concat(JSON.stringify(e)),n.appendChild(r),this.outputElement.appendChild(n)}}function _setupShims(){for(const e of Object.keys(console))"function"!=typeof console[e]||this[e]||(this[e]=()=>{})}function _addToOutput(e){const t=document.createElement("div"),n=e.reduce(((e,t)=>"object"==typeof t?e+JSON.stringify(t)+" ":e+String(t)+" "),"");t.textContent=n,this.outputElement.appendChild(t)}async function runJavaScriptCode(e){try{const{outputElement:t,clearClicked:n}=getOutputElement(e);showLoader(t);const r=new CustomConsole(t),s=e.textContent,i=Sandbox.SAFE_PROTOTYPES;i.set(CustomConsole,new Set);const o={...Sandbox.SAFE_GLOBALS,alert:r.alert.bind(r),console:r,setTimeout,clearTimeout,setInterval,clearInterval},a=new Sandbox({globals:o,prototypeWhitelist:i}),c={},l=a.compileAsync(s),p=Date.now(),d=await Promise.race([l(c).run(),n]),u=Date.now();if(hideLoader(t),d===clearedSymbol)return;r.addResult(d,u-p)}catch(e){console.error("Error running code",e),toastr.error("Error running code",e.message)}}async function runSTScriptCode(e){try{const{outputElement:t,clearClicked:n}=getOutputElement(e),r=e.textContent,s=new AbortController,i=new CustomConsole(t);showLoader(t);const o=Date.now(),a=executeSlashCommands(r,!0,null,!1,null,s,((e,t)=>{})),c=await Promise.race([a,n]);if(hideLoader(t),c===clearedSymbol)return void s.abort();const l=Date.now();i.addResult(null==c?void 0:c.pipe,l-o)}catch(e){console.error("Error running code",e),toastr.error("Error running code",e.message)}}})()})();